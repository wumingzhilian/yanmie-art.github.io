---
 layout:  post    # 使用的布局（不需要改）
 title:  python实现客户端服务算通讯  # 标题 
 subtitle:  ctfshow   #副标题
 date:  2020-11-23  # 时间
 author:  yanmie    # 作者
 header-img: img/.jpg ##标签这篇文章标题背景图片
 catalog: true      # 是否归档
 tags:        
   - 工具使用

---

# python 通讯

## 一、TCP

**基于tcp协议socket,需先启动服务端，在启动客户端**

#### **1、单人连接**

server:

```python
import socket

sk = socket.socket()    #默认参数
sk.bind(('127.0.0.1',9000))
sk.listen()    # n

# 接受客户端链接 connection 连接 address 地址
conn,addr = sk.accept()    # 阻塞   三次握手过程
while True:
    msg = conn.recv(1024).decode('utf-8')
    if msg.upper() == 'Q':
        break;
    print(msg)
    inp = input('>>>')
    conn.send(inp.encode('utf-8'))
    if inp.upper() == 'Q':
        break
print('通讯已结束')
conn.close()     # 如果写成，sk.close()  会把所有与服务端通信的链接都断掉
```

client:

```python
import socket

sk = socket.socket()
sk.connect(('127.0.0.1',9000))   # 三次握手过程
while True:
    inp = input('>>>')
    sk.send(inp.encode('utf-8'))  # 编码啥都可以，只要转过去，接收时在转回来就可
    if inp.upper() == 'Q':
        break
    msg = sk.recv(1024).decode('utf-8')
    if msg.upper() == 'Q':
        break;
    print(msg)
print('通讯已结束')
sk.close()
```

这时利用循环可以达到无限聊天的效果，但是如果有多个客户端要连接服务端是不可以的。

因为这里一旦初始连接起来的客户端和服务器任何一端按`q`之后，他们都`sk.close()` 关闭链接了。

所以会导致在同一时间的另外其他想链接服务端客户端在等待服务端与其他客户端聊天结束后，会发生错误，因为此时服务端已经不在监听这个端口了。

#### 2、解决多人连接问题

我们可以利用循环嵌套，将`conn,addr = sk.accept() ` 进行循环，这样在小循环结束后，如有客户端还在等待响应，那么服务端就可以继续进行通信了。

server:

```python
import socket

sk = socket.socket()    #默认参数
sk.bind(('127.0.0.1',9000))
sk.listen()    # n

while True:
    conn,addr = sk.accept()    # 阻塞   三次握手过程
    while True:
        msg = conn.recv(1024).decode('utf-8')
        if msg.upper() == 'Q':
            break;
        print(msg)
        inp = input('>>>')
        conn.send(inp.encode('utf-8'))
        if inp.upper() == 'Q':
            break
print('通讯已结束')
conn.close()     # 如果写成，sk.close()  会把所有与服务端通信的链接都断掉
```

client1:

```python
import socket

sk = socket.socket()
sk.connect(('127.0.0.1',9000))   # 三次握手过程
while True:
    inp = input('>>>')
    sk.send(inp.encode('utf-8'))  # 编码啥都可以，只要转过去，接收时在转回来就可
    if inp.upper() == 'Q':
        break
    msg = sk.recv(1024).decode('utf-8')
    if msg.upper() == 'Q':
        break;
    print(msg)
print('通讯已结束')
sk.close()
```

client2:

```python
import socket

sk = socket.socket()
sk.connect(('127.0.0.1',9000))   # 三次握手过程
while True:
    inp = input('>>>')
    sk.send(inp.encode('utf-8'))  # 编码啥都可以，只要转过去，接收时在转回来就可
    if inp.upper() == 'Q':
        break
    msg = sk.recv(1024).decode('utf-8')
    if msg.upper() == 'Q':
        break;
    print(msg)
print('通讯已结束')
sk.close()
```

那么我们来实操一下/

先运行服务端，在运行客户端1，客户端2.

[![DJPMIe.md.png](https://s3.ax1x.com/2020/11/23/DJPMIe.md.png)](https://imgchr.com/i/DJPMIe)

可以看到，此时只能服务端与客户端1 之间通信。而客户端2这边处于等待状态。

[![DJPadS.md.png](https://s3.ax1x.com/2020/11/23/DJPadS.md.png)](https://imgchr.com/i/DJPadS)

又可以看到，当服务端与客户端1之间断开连接时，服务端此时收到了之前客户端2发送的数据。

继续看

[![DJinln.md.png](https://s3.ax1x.com/2020/11/23/DJinln.md.png)](https://imgchr.com/i/DJinln)

此时服务端可以和客户端2正常通信，但是当输入`q` 断开连接的时候，客户端2断开了，而服务端还在阻塞`conn,addr = sk.accept() `。

虽然实现了可以聊完一个在接着一个聊天，但是此时服务端永远也不会停止下来，一直会循环阻塞接收连接。。。。。。但这也不是坏事把。。

``` 
sk.listen()    # n 代表允许多少个客户端在等待
```





## 二、UDP

udp是无链接的，启动服务之后可以直接接受消息，不需要提前建立链接

在启动服务之后只能被动的等待客户端发送信息

客户端发送消息的同时还会自带地址信息

消息回复的时候，不仅需要发送消息，还需要把对方的地址发送过来

#### 1、单人连接

server:

```python
import socket

sk = socket.socket(type=socket.SOCK_DGRAM)   # 指定UDP协议
sk.bind(('127.0.0.1',9000))

ret = sk.recvfrom(1024)   # 不知道谁来连接服务端，用recvfrom 返回信息+地址
print(ret)

sk.close()
```

client:

```python
import socket

sk = socket.socket(type=socket.SOCK_DGRAM)

sk.sendto(b'hello',('127.0.0.1',9000))      # 不需要 connect ,UDP不需要三次握手

sk.close()
```

[![DJkFPg.md.png](https://s3.ax1x.com/2020/11/23/DJkFPg.md.png)](https://imgchr.com/i/DJkFPg)

上述代码服务端接收信息`(b'hello', ('127.0.0.1', 63184))`

#### 2、实现单个客户端通信

server:

```python
import socket

sk = socket.socket(type=socket.SOCK_DGRAM)   # 指定UDP协议
sk.bind(('127.0.0.1',9000))
while True:
    msg,client_addr = sk.recvfrom(1024)   # 不知道谁来连接服务端，用recvfrom 返回信息+地址
    print(msg.decode('utf-8'))
    inp = input('>>>').encode('utf-8')
    sk.sendto(inp,client_addr)     # 回复消息用到地址

sk.close()
```

client:

```python
import socket

sk = socket.socket(type=socket.SOCK_DGRAM)

while True:
    inp = input('>>>').encode('utf-8')
    sk.sendto(inp,('127.0.0.1',9000))      # 不需要 connect ,UDP不需要三次握手
    # ret = sk.recvfrom(1024)
    # print(ret)     # (b'received', ('127.0.0.1', 9000))
    msg = sk.recv(1024)   # 此时已经知道对方是127.0.0.1:9000
    print(msg.decode('utf-8'))     # b'received'
sk.close()
```

此时客户端与服务端可以一直发送数据了。

#### 3、多个客户端通信

因为是UDP的，所以不像是TCP基于连接的得等待一个完了之后在一个。

所以只需直接在启动客户端2 即可。

效果：

[![DJZu6J.md.png](https://s3.ax1x.com/2020/11/23/DJZu6J.md.png)](https://imgchr.com/i/DJZu6J)

UDP 谁给服务端发信息，服务端照收，然后发给哪个地址的客户端。

所以UDP比较适合聊天。。。。

