## 一、面向对象

#### 1.1 什么是面向对象

分类

面向对象编程（Object-Oriented Programming,OOP）

本质：以类的方式组织代码，以对象的方式组织（封装）数据。

**抽象**

**特性：**

* 封装
* 继承
* 多态

#### 1.2 方法回顾

方法定义：

* 修饰符
* 返回类型
* break, return
* 方法名
* 参数列表
* 异常抛出

方法调用：

* 静态方法
* 非静态方法
* 形参和实参
* 值传递和引用传递
* this 关键字

#### 1.3 类和对象的创建

student.java

```java
package com.oop.demo01;

// 学生类
public class Student {
    // 属性
    String name;
    int age;

    // 方法
    public void study(){
        System.out.println(this.name+"在学习");
    }
}
```

demo:

```java
package com.oop.demo01;

// 一个项目中只有一个 main 方法
public class Demo02 {
    public static void main(String[] args) {
        // 类：抽象的，需要实例化
        Student student = new Student();
        System.out.println(student.name);  // null
        student.name = "小明";
        student.study();    // 小明在学习
    }
}
```

#### 1.4 构造器

使用 new 关键字创建的时候，出了分配内存空间之外，还会给 创建好的对象 进行默认的初始化以及对类中构造器的调用。

构造器也成为构造方法：

* 必须和类的名字相同
* 必须没有返回类型，也不能写 void

```java
package com.oop.demo01;

public class Person {
    // 默认存在
    public Person(){
        
    }
}
```

```java
package com.oop.demo01;

public class Person {
    String name;

    // 实例化初始值
    public Person(){
        this.name = "Tom";
    }
}

```

```java
package com.oop.demo01;

public class Person {
    String name;

    // 实例化初始值
    public Person(){
        
    }
    // 重载
    public Person(String name){
        this.name = name;
    }
}
```

```java
package com.oop.demo01;

public class Demo03 {
    public static void main(String[] args) {
        Person person = new Person();
        System.out.println(person.name);
        System.out.println(new Person("Mike").name);
    }
}
```

#### 1.5 创建对象内存分析

#### 1.6 小结

类是一个模板： 抽象

对象是一个具体实例

对象是通过引用来操作的。

#### 1.7 封装

**高内聚，低耦合。**

属性私有： get/set

* 提高程序安全性
* 隐藏代码实现细节
* 统一接口
* 系统可维护增加了

Student.java

```java
package com.oop.demo03;

public class Student {
    // 属性私有
    private String name;
    private int id;
    private char sex;

    public String getName(){
        return this.name;
    }
    public void setName(String name){
        this.name = name;
    }
}

```

Application.java

```java
package com.oop.demo03;

public class Application {
    public static void main(String[] args) {
        Student student = new Student();
        String name = student.getName();
        System.out.println(name);
        student.setName("Tom");
        System.out.println(student.getName());
    }
}
```

#### 1.8 继承

继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。

`extends` 的意思是扩展，子类是父类的扩展。

Java 中只有单继承，没有多继承。

**子类继承私有属性无法继承，受保护可继承。**

Person.java

```java
package com.oop.demo04;

public class Person {
    protected String name;
    private double money;
    public Person(){
        this.name = "人";
    }
    public void say(){
        System.out.println(this.name+"说话了");
    }
}
```

Teacher.java

```java
package com.oop.demo04;

public class Teacher extends Person{
    public  Teacher(){
        this.name = "老师";
    }
}
```

Student.java

```java
package com.oop.demo04;

public class Student extends Person{
    public Student(){
        this.name = "学生";
    }
}
```

Application.java

```java
package com.oop.demo04;

public class Application {
    public static void main(String[] args) {
        Student student = new Student();
        student.say();     // 学生说话了
        new Teacher().say();  // 老师说话了
    }
}
```

**在 Java 中所有的类，都默认直接或间接继承 Object**

**Ctrl+h  快捷键 显示类的层次结构**

#### 1.9 Super

子类调用构造器时先调用父类构造器。(默认会隐藏).

Person.java

```java
package com.oop.demo05;

public class Person {
    protected String name="Person";
    public Person(){
        System.out.println("父类构造方法执行了");
    }

    public void print(){
        System.out.println("Person.print");
    }

}
```

Student.java

```java
package com.oop.demo05;

public class Student extends Person{
    private String name="Student";

    public Student(){
        // super();  // 默认隐藏就有
        System.out.println("子类的构造方法执行了");
    }

    public void print(){
        System.out.println("Student.print");
    }

    public void test(String name){
        System.out.println(name);
        System.out.println(this.name);
        System.out.println(super.name);
    }

    public void test1(){
        print();
        this.print();
        super.print();
    }
}
```

Application.java

```java
package com.oop.demo05;

public class Application{
    public static void main(String[] args) {
        Student student = new Student();
        student.test("Application");
        student.test1();
    }
}
```

结果

```txt
父类构造方法执行了
子类的构造方法执行了
Application
Student
Person
Student.print
Student.print
Person.print
```

#### 1.10 方法重写

A.java

```java
package com.oop.demo06;

// 重写是方法的重写，和属性无关
public class A {
    public static void test(){
        System.out.println("A->test()");
    }

    public void test1(){
        System.out.println("A->test1()");
    }
}
```

B.java

```java
package com.oop.demo06;

public class B extends A{
    public static void test(){
        System.out.println("B->test()");
    }

    public void test1(){
        System.out.println("B->test1()");
    }
}
```

Application.java

```java
package com.oop.demo06;

public class Application {
    public static void main(String[] args) {
        B b = new B();
        b.test();

        // 父类的引用指向了子类
        A a = new B();
        a.test();

        // 静态方法和非静态方法不一样，子类方法重写了父类方法
        b.test1();
        a.test1();

    }
}
```

结果：

```txt
B->test()
A->test()
B->test1()
B->test1()
```

重写：需要有继承关系，子类重写父类方法

* 方法名必须相同
* 参数列表必须相同
* 修饰符：范围可扩大但不能缩小  public -> protected -> default -> private
* 抛出异常：范围可以被缩小，但不能扩大

#### 1.11 多态

Person.java

```java
package com.oop.demo07;

public class Person {
    public void run(){
        System.out.println("Person.run");
    }
}

```

Student.java

```java
package com.oop.demo07;

public class Student extends Person{
    public void run(){
        System.out.println("Student.run");
    }
    public void eat(){
        System.out.println("Student.eat");
    }
}

```

Application.java

```java
package com.oop.demo07;

public class Application{
    public static void main(String[] args) {
        Student s1 = new Student();
        Person s2 = new com.oop.demo07.Student();
        Object s3 = new com.oop.demo07.Student();

        s2.run();
        s1.eat();
        // 子类可以调用自己的方法或者父类继承的方法
        s1.run();
        // Person 夫类型可以指向子类，但不能调用子类的方法
        //s3.run();
        //s2.eat();
        // 类型转换，高转低
        ((Student)s2).eat();

    }


}
```

#### 1.12 instanceof 和 类型转换

instanceof (类型转换) 引用类型，判断一个对象是什么类型。

Person.java

```java
package com.oop.demo08;

public class Person {
    public void run(){
        System.out.println("Person.run");
    }
}
```

Teacher.java

```java
package com.oop.demo08;

public class Teacher extends Person{
}
```

Student.java

```java
package com.oop.demo08;

public class Student extends Person{
}
```

Application.java

```java
package com.oop.demo08;

import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;
import sun.nio.cs.ext.IBM037;

public class Application {
    public static void main(String[] args) {
        Object object = new Student();

        System.out.println(object instanceof Student);  // true
        System.out.println(object instanceof Person);   // true
        System.out.println(object instanceof Object);   // true
        System.out.println(object instanceof Teacher);  // false
        System.out.println(object instanceof String);  // false

        Person person = new Student();
        System.out.println(person instanceof Student);  // true
        System.out.println(person instanceof Person);   // true
        System.out.println(person instanceof Object);   // true
        System.out.println(person instanceof Teacher);  // false
        //System.out.println(person instanceof String);  // 编译报错

    }
}
```

类型转换：

* 父类引用指向子类
* 把子类转换为父类，向上转型
* 把父类转换为子类，向下转型： 强制转换
* 方便方法的调用

#### 1.13 static关键字

Student.java

```java
package com.oop.demo09;

public class Student {
    private static int age;  // 静态变量
    private double score;

    public void run(){

    }
    // 静态方法
    public static void go(){}

    public static void main(String[] args) {
        Student student = new Student();
        Student.age = 11;   // 通过类访问静态变量

        System.out.println(Student.age);
        System.out.println(student.age);
        System.out.println(student.score);

        student.run();
        student.go();
        Student.go();   // 通过类直接调用静态方法
        go();
    }
}
```

代码块：

```java
package com.oop.demo09;

public class Person {
    {
        // 匿名代码块
        System.out.println("匿名代码块");
    }

    static{
        // 静态代码块
        System.out.println("静态代码块");
    }
    public Person(){
        System.out.println("构造方法");
    }

    public static void main(String[] args) {
        new Person();
        System.out.println("--------");
        new Person();
    }
}
```

得到：

```txt
静态代码块
匿名代码块
构造方法
--------
匿名代码块
构造方法
```

说明：  代码块比构造方法更先执行，静态代码块只执行一次，匿名代码块new就会执行。



**被 `final` 定义的不能被继承了。**

#### 1.14 抽象类

abstract 关键字。

```java
package com.oop.demo10;

// abstract 抽象类
public abstract class Action {
    // 约束
    // abstract 抽象方法，只有方法名字，没有方法的实现
    public abstract void doSomething();
}

```

继承

```java
package com.oop.demo10;

// 抽象类的所有方法，继承了它的子类必须实现它的方法
public class A extends Action{
    public void doSomething(){}
}
```

抽象类不能被实例化，也就是不能被 `new` 。

#### 1.15 接口的定义与实现

普通类：只有具体实现

抽象类：具体实现和规范（抽象方法）都有

接口：只有规范

声明类的关键字是 class, 声明接口的关键字是 interface

UserService.java

```java
package com.oop.demo11;

public interface UserService {
    // 接口中的所有定义其实都是抽象的 public abstract
    // public abstract void run();
    void add(String name);
    void delete(String name);
    void update(String name);
    void query(String name);

}
```

TimeService.java

```java
package com.oop.demo11;

public interface TimeService {
    void timer();
}
```

UserSeriviceImpl.java

```java
package com.oop.demo11;

// 类 可以实现接口  implements 接口
// 实现了接口的类，就需要重写接口的所有方法
// 利用接口实现多继承
public class UserServiceImpl implements UserService,TimeService{
    @Override
    public void add(String name) {

    }

    @Override
    public void delete(String name) {

    }

    @Override
    public void update(String name) {

    }

    @Override
    public void query(String name) {

    }

    @Override
    public void timer() {

    }
}
```

作用：

* 约束
* 定义一些方法，让不同的人实现
* 方法都是 public abstract
* 常量是 public static final
* 接口不能被实例化， 接口没有构造方法
* implements 可以实现多个接口
* 必须重写接口中的方法

#### 1.16 内部类

内部类就是在一个类的内部定义一个类，比如，A类中定义一个B类，那么 B类相对 A 类来说就成为 内部类，而 A 类相对 B 类就是外部类了。

* 成员内部类
* 静态内部类
* 局部内部类
* 匿名内部类

Outer.java

```java
package com.oop.demo12;

public class Outer {
    private int id;
    public void out(){
        System.out.println("这是外部类的方法");
    }

    public class Inner{
        public void in(){
            System.out.println("这是内部类的方法");
        }
        // 获得外部类的私有属性
        public void getID(){
            System.out.println(id);
        }
    }
}

```

Applcation.java

```java
package com.oop.demo12;

public class Application {
    public static void main(String[] args) {
        Outer outer = new Outer();
        // 通过外部类来实例化内部类
        Outer.Inner inner = outer.new Inner();
        inner.in();
        inner.getID();
    }
}

```

静态内部类， 不能访问外部类的私有属性了。

 ## 二、异常

#### 2.1 Error 与 Exception

![image-20210207123847564](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210207123847564.png)



#### 2.2 捕获和抛出异常

```java
package com.exception;

public class Test {
    public static void main(String[] args) {
        int a = 1;
        int b = 0;
        try{   // try 监控区域
            System.out.println(a/b);
        }catch (ArithmeticException e){  // catch 捕获异常
            System.out.println("程序出现异常！");
        }finally{   // 处理善后工作
            System.out.println("finally");
        }

    }
}
```

```java
package com.exception;

public class Test {
    public static void main(String[] args) {
        int a = 1;
        int b = 0;
        try{   // try 监控区域
            new Test().a();
        }catch (Error e){  // catch 捕获异常
            System.out.println("程序出现异常！");
        }finally{   // 处理善后工作
            System.out.println("finally");
        }

    }

    public void a(){
        b();
    }
    public void b(){
        a();
    }
}
```

主动抛出异常：

```java
package com.exception;

import jdk.nashorn.internal.runtime.ECMAException;

public class Test {
    public static void main(String[] args) {
        int a = 1;
        int b = 0;
        try{   // try 监控区域
            if(b==0){    // 主动抛出异常
                throw new ArithmeticException();
            }
            System.out.println(a/b);
        }catch (Exception e){  // catch 捕获异常
            System.out.println("程序出现异常！");
        }finally{   // 处理善后工作
            System.out.println("finally");
        }

    }

}
```

#### 2.3 自定义异常

















