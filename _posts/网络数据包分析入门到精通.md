---
layout:  post    # 使用的布局（不需要改）
title:  网络数据包分析入门到精通   # 标题 
subtitle:    #副标题
date:  2021-03-06  # 时间
author:  yanmie    # 作者
header-img: img/.jpg ##标签这篇文章标题背景图片
catalog: true      # 是否归档
tags:        
    - 网络安全
---


# 网络数据包分析入门到精通

## 一、基础篇

#### 1.1 认识 wireshark 的界面

实验目的

- 认识Wireshark的界面。

实验工具

- `wireshark`：Beyond Compare是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换，是目前全世界最广泛的网络封包分析软件

- 实验文件：
  - `Lab1-1.pcapng`  

**wireshark 主窗口页面**

![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/01.jpg)

* 标题栏：用于显示所分析的抓包文件的名称、捕获的设备名称以及Wireshark的 版本号。 
* 菜单栏：Wireshark的标准菜单栏。 
* 工具栏：常用功能的快捷图标按钮。
* 筛选区域：我们在实际的数据包分析中，可能在很短的时间内就能够捕获到成 千上万的数据包信息。这个时候就需要使用这里的筛选器，加上一定的条件，筛 选掉我们并不关心的数据包，从而更好地进行分析。
* Packet List面板：显示每个数据帧的摘要，这里采用表格的形式列出了 当前捕获文件中的所有数据包，其中包括了数据包序号、数据包捕获的相对时 间、数据包的源地址和目标地址、数据包的协议以及在数据包中找到的概 况信息等。 
* Packet Details 面板：分析数据包的详细信息。这个面板分层次的显示了一个数据包中的内容，并且可以通过展开或者收缩来显示这个数据包中所捕获的全部内容。
* Packet Bytes面板：以十六进制和ASCII码的形式显示数据包中的内容。这里显示了一个数据包未经处理的原始样子，也就是在链路上传播时的样子。
* 状态栏：包含有专家信息、注释、包的数量和Profile 。

**认识数据包：**

在 Wireshark 中，关于数据包的叫法主要有3个述语，就是 帧、包、段。

数据帧的初始起点和目的点都是数据链路层。

数据包的起始和目的地是网络层

段通常是指起始点和目的地都是传输层的信息单元。

我们在wireshark 中分析 http 协议的包

![image-20210302091451706](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302091451706.png)

这里主要显示了 五中协议的信息

* Frame：物理层数据帧的情况。
* Ethernet II : 数据链路层以太网帧头部的信息。
* Internet Protocol Version 4 : 网络层 IP 包的头部信息。
* Transmission Control Protocol : 传输层的数据段头部信息，这里是 TCP 协议。
* Hypertext Transfer Protocol : 应用层信息，这里显示的是 HTTP 协议。

**具体分析：**

**物理层数据帧的情况：**

```txt
# 518 号帧，线路上有 326 个字节，实际捕获 326 个字节。
Frame 518: 326 bytes on wire (2608 bits), 326 bytes captured (2608 bits) on interface \Device\NPF_{735DCADA-7E52-4B1F-AE8A-073582180A9C}, id 0

# 接口ID
Interface id: 0 (\Device\NPF_{735DCADA-7E52-4B1F-AE8A-073582180A9C})

# 数据封装类型：
Encapsulation type: Ethernet (1)

# 捕获日期时间
Arrival Time: Mar  2, 2021 09:05:06.783557000 中国标准时间

# 当前数据包与前一个数据包的时间间隔
[Time delta from previous captured frame: 0.001013000 seconds]

# 当前数据包与先前显示的帧的时间增量
[Time delta from previous displayed frame: 0.036520000 seconds]

# 当前数据包与第一个数据包的时间间隔
[Time since reference or first frame: 57.053413000 seconds]

# 帧序号
Frame Number: 518

# 帧长度
Frame Length: 326 bytes (2608 bits)

# 捕获长度
Capture Length: 326 bytes (2608 bits)

# 帧是否被标记： 否
[Frame is marked: False]

# 帧是否被忽略： 否
[Frame is ignored: False]

# 帧内封装的协议层次结构
[Protocols in frame: eth:ethertype:ip:tcp:http]

# 着色标记的协议名称
[Coloring Rule Name: HTTP]

# 着色规则显示的字符串
[Coloring Rule String: http || tcp.port == 80 || http2]
```

**数据链路层以太网帧的信息**

```txt
Ethernet II, Src: RuijieNe_81:96:4b (14:14:4b:81:96:4b), Dst: IntelCor_d7:57:7b (74:e5:f9:d7:57:7b)

# 目的mac地址 
Destination: IntelCor_d7:57:7b (74:e5:f9:d7:57:7b)

# 源mac地址
Source: RuijieNe_81:96:4b (14:14:4b:81:96:4b)

# IPv4 协议
Type: IPv4 (0x0800)
```

**网络层 IP 包的头部信息**

```txt
Internet Protocol Version 4, Src: 180.101.49.12, Dst: 10.141.8.188

# 互联网协议 IPv4
0100 .... = Version: 4

# IP报头长度 20 字节
.... 0101 = Header Length: 20 bytes (5)

# 差分服务字段
Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)

# IP包总长度
Total Length: 312

# 标志字段
Identification: 0xe6cf (59087)

# 标记字段
Flags: 0x40, Don't fragment

# 分片偏移
Fragment Offset: 0

# 生存期
Time to Live: 40

# 当前数据包所封装的上层协议为 TCP协议
Protocol: TCP (6)

# 头部数据的校验和
Header Checksum: 0x7236 [validation disabled]
    [Header checksum status: Unverified]

# 源 IP 地址
Source Address: 180.101.49.12

# 目的 IP 地址
Destination Address: 10.141.8.188
```

**传输层 TCP 数据段的头部信息**

```txt
Transmission Control Protocol, Src Port: 80, Dst Port: 39922, Seq: 2, Ack: 207, Len: 272

# 源端口号
Source Port: 80

# 目的端口号
Destination Port: 39922
    
[Stream index: 11]
[TCP Segment Len: 272]

# 序列号（相对序列号）
Sequence Number: 2    (relative sequence number)
Sequence Number (raw): 1908169095

# 下一个序列号（相对序列号）
[Next Sequence Number: 274    (relative sequence number)]

# 确认序列号 
Acknowledgment Number: 207    (relative ack number)
Acknowledgment number (raw): 1369554583

# 头部长度
0101 .... = Header Length: 20 bytes (5)

# TCP 标记字段
Flags: 0x018 (PSH, ACK)

# 流量控制的矿口大小
Window: 1008
[Calculated window size: 1008]
[Window size scaling factor: -1 (unknown)]

# TCP 数据段的校验和
Checksum: 0xcfdb [unverified]
[Checksum Status: Unverified]


Urgent Pointer: 0
[Timestamps]
TCP payload (272 bytes)

```

**传输层**

为 http 报文

```txt
Hypertext Transfer Protocol
    HTTP/1.1 200 OK\r\n
    Accept-Ranges: bytes\r\n
    Content-Encoding: gzip\r\n
    Content-Length: 232\r\n
    Content-Type: text/plain\r\n
    Date: Tue, 02 Mar 2021 01:05:07 GMT\r\n
    Etag: "afe-59b382b3e5a89"\r\n
    Last-Modified: Fri, 03 Jan 2020 08:33:49 GMT\r\n
    Server: Apache\r\n
    Vary: Accept-Encoding,User-Agent\r\n
    \r\n
    [HTTP response 1/2]
    [Time since request: 0.036520000 seconds]
    [Request in frame: 516]
    [Next request in frame: 1646]
    [Request URI: http://www.baidu.com/robots.txt]

```

**筛选器的简单用法**

Wireshark的筛选器可以让我们找出我们所希望进行分析的`数据包`。简单来说， 一个筛选器就是定义了一定的条件，用来包含或者排除数据包的表达式。如果在实 际的分析中，不希望看到某一些数据包，那么就可以通过筛选器来`屏蔽`掉它们， 从而只显示我们感兴趣的内容。但是这里需要注意的是，有些时候，我们在进行网 络分析时，可能会因为设置了不恰当的筛选器而漏掉了一些关于这个网络情况的关 键数据，所以筛选器有时候也是一把`双刃剑`。

筛选器也支持与 （and）、或（or）、非（not）等逻辑运算符，可以`加强`筛选的效率。

查询所有包含 IP 地址为 180.101.49.12 ，端口号为 80 的数据包：

```txt
ip.addr==180.101.49.12 and tcp.port==80ip.addr==180.101.49.12
```

查询所有非 HTTP 协议：

```txt
!http
```

比较操作符，查看长度小于等于 150 字节的数据包：

```txt
frame.len<=150
```

Wireshark的`协议域`筛选器。这个功能可以帮助我们通过检查协议 头中的某一个字节来创建筛选条件，或者也可以匹配一个数据包中从某一特定位置 开始一定数量的字节。举例来说，比如我们想捕获带有(PSH,ACK)标志的`TCP数据 包`。那么就可以检测TCP协议中偏移为13的标志位的情况。尽管这个标志位只有1 个字节，但是这个字节中的每一个比特位都是一个标志。

```txt
tcp[13]==0x18
```

如果我们在实际的分析过程中发现某一个筛选条件使用的比较`频繁`，那么可以考 虑将这个筛选条件保存下来，避免每次分析中的重复输入。我们可以在菜单栏中选 择“**Analyze**”->“**Display Filter**”，打开Display Filter对话框。

单击左边的`New`按钮，创建一个新的筛选器。并且在“**Filter Name**”中给 筛选器起一个名字，在“**Filter String**”中输入筛选表达式，之后单 击“**OK**”进行保存即可.

#### 1.2 Wireshark 的实用表格

**实验目的**

本课程我们将学习Wireshark的实用表格。

**实验工具**

- `wireshark`：它是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换，是目前全世界最广泛的网络封包分析软件

实验文件：

- `Lab2-1.pcapng`  
- `Lab2-2.pcap`
- `maxmind` 

关于网络中的端点以及会话的知识。在网络中，如果想让通信得 到正常的执行，那么就必须至少拥有两台设备或者说端点（EndPoint）进行数 据的交互操作。所谓的端点，就是指网络上用于发送或者接收数据的设备。比如在 基于TCP/IP协议的通信中，就包含有两个端点：发送方和接收方的IP地址， 结合着实验文件（Lab2-1）可以发现，对于捕获的第1个数据包来说，发送方的IP 地址是180.97.34.134，而接收方的IP地址是192.168.0.14。那么这两个IP地址其 实就是两个端点，


而在数据链路层，通信则是基于两台主机中安装的网卡和它们的MAC地址进行 的。依旧分析一下第1个数据包，我们在Packet Details面板中展开Ethernet II ，可以看到发送方的地址是94:de:80:d4:be:c9，而接收方的地址是 d0:fa:1d:61:0b:0c。那么这两个地址就是通信中的端点。



我们在实际分析过程中，面对网络流量的时候，可以将问题定位到网络中的一个特 定的端点上。可以在菜单栏中选择“Statistics”->“Endpoints”来打 开Endpoints窗口(菜单栏的统计里的端点)：

![image-20210302110541249](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302110541249.png)

可以看到，这个窗口给出了端点中的非常多的有用的数据。在其顶部的选项卡中， 显示了当前捕获文件中所有被支持和识别的端点，每个选项卡都表示不同的`协议` 

- **Address**：端点的地址
- **Packets**：在捕获文件中包含该地址的数据包数量。
- **Bytes**：数据包的字节数据。
- **Tx Packets**：发送的数据包数量。
- **Tx Bytes**：发送的数据包的字节数。
- **Rx Packets**：接收的数据包数量。
- **Rx Bytes**：接收的字节数

在这个窗口中还包含有名为“**Name resolution**” (解析名称) 的多选框，它可以在端点窗 口中打开名字解析的功能。把断点地址解析相关厂商。

**查看网络会话信息**

所谓的`网络会话`（Conversation）可以理解为两个人之间的谈话，只不过网络 会话描述的是两台主机（端点）之间进行的`通信活动`。对于TCP协议来说，最常 见的会话就是连接建立时的三次握手了。可以在菜单栏中选择“**Statistics** ”->“**Conversations**”来打开`Conversations`窗口：

![image-20210302110915726](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302110915726.png)

与Endpoints窗口相同，Conversations窗口中所列出的会话同样以不同的协议分布在不同的选项卡中，这可以通过顶部的选项卡进行切换。如果我们右键单击一个会话，选择“**Apply as Filter**”->“**Selected**”就可以创建一些非常实用的筛选器，比如显示由设备A发出的所有数据，设备B收到的所有数据，或者设备A和B之间的所有通信数据等。而一旦我们选择了其中的某一项筛选条件，那么回到Wireshark主界面时，在筛选条件输入框中，自动就会添加上刚才选择的条件：

![image-20210302111027857](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302111027857.png)

![image-20210302111049454](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302111049454.png)

**使用端点和会话分析网络问题**

在排解网络问题的过程中，`端点`和`会话窗口`往往扮演着非常重要的角色。当我

们试图寻找网络中大规模流量的源头，或者查找哪台服务器最为活跃上面，这两个窗口往往就能告诉我们一切。帅选保留`http协议`的数据包。可以发现，有多个客户端在浏览互联网时产生了大量的`http流量`。那么现在我们可以使用端点窗口来查看一下具体的情况：

![image-20210302112638728](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302112638728.png)

这里我们查看IPv4选项卡，并且以字节数从高到低进行排序。可以看到流量最大的是 10.141.8.188 这个地址，其实也就是`本机地址`，说明网络中的这个设备是数据集中最活跃的信息源，也就是进行了最多通信的主机。第二个地址是180.97.125.228，并不是本地地址，那么就可以假设本地某一个或者多个客户端与这个地址进行了一些交互。

![image-20210302112753490](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302112753490.png)

可以发现，这个IP地址属于 gitee.com. 

**协议的分层统计**

当我们在分析一个很大的`捕获文件`时，我们往往想要知道文件中协议的分布情况，或者想要获取协议的多层结构信息。为了达到这个目的，我们可以使用Wireshark的`“协议分层统计”`功能，它是对网络进行基准分析的强有力的工具。举个例子来说，假设我们网络中的ARP流量通常占百分之十，但是某一天经过抓包分析发现ARP的流量增长到了百分之五十，那么就可以知道一定是某个地方出了问题。

在菜单栏中选择“**Statistics**”->“**Protocol Hierarchy**” （统计---> 协议分级），打开协议分层统计窗口：

![image-20210302113103962](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302113103962.png)

这个对话框显示了捕获的文件中所包含的所有协议的`树状分支`。其中的每一行都包含一个协议层次的统计值，每列的含义如下：

#### 1.3 Wireshark 的图形显示

实验目的

通过wireshark图形学习，认识IO Graphs、Round Trip Time Graph等功能

选择一个TCP 数据包， 菜单栏 统计---> IO Graphs



**认识 IO Graphs**

之前各种实用的表格虽然能够有效辅助我们的分析，但是如果想要更好的了解我们所分析的网络情况，则需要依靠Wireshark的图形功能来直观地展示出来。

首先介绍一下`IO Graphs`。这个窗口可以让我们对网络上的`数据吞吐`情况进行绘图。这样就可以很容易地发现数据吞吐的峰值，找出不同协议中的性能瓶颈，并且还可以用来比较实时的数据流。

**认识Round Trip Graph**

Wireshark的另一个绘图功能就是对所捕获的文件进行往返时间的绘图。`往返时间`（round-trip time, RTT）是指一个数据包从发出到确认被成功接收所需要的时间。或者说，往返时间就是数据包抵达目的地的时间，加上收到对方的确认信息的时间之和。通过对这个时间的分析，可以找到通信中的瓶颈，确定是否存在延迟。

**认识Flow Graph**

`数据流图`功能可以将连接可视化，并且将一段时间中的数据流显示出来。数据流图一般以`列`的方式将主机之间的连接显示出来，并将数据组织到一起，便于更加直观地解读。

#### 1.4 Wireshark 的高级特性

**协议解析**

`Wireshark`最为强大的功能之一就是协议解析功能，也是我们最为常用的功能。尽管我们往往不会注意这个功能，但是它却一直实实在在地影响着我们的分析过程。协议的解析是由Wireshark的协议解析器完成的，它可以将网络上获取的原始二进制数据包进行拆分，变成相关协议的不同区段，以便于我们的分析。比如我们之前接触过多次的`TCP协议`，一旦Wireshark捕获到该协议的数据包，就会自动分析，并且以TCP数据包的格式显示出来，告诉我们每一个数据段的意义。

我们可以将Wireshark的协议解析器看作是`网络原始数据流`和Wireshark软件之间的翻译器。如果想要让Wireshark支持某个协议，那么它就必须拥有该协议的`解析器`。当然如果我们在实际的分析过程中遇到了新的协议，也可以使用C语言或者Python来自己编写一个解析程序。

但是这里需要注意的是，Wireshark在进行协议解析的时候并不见得每次都会选择出正确的解析器，尤其是当网络上的一个协议使用了不同于标准的配置时，往往会出现错误的协议解析。一旦遇到这种情况，我们就需要更改Wireshark的协议解析方式。

**追踪TCP流**

TCP流量可以说是我们在日常的分析中遇到最多的数据包了。而Wireshark为了方便我们的分析，可以将`TCP流`重组成易于阅读的形式，而不是一小块一小块地查看。

右键单击任意一个TCP或者HTTP数据包，并选择**“Follow TCP Stream”**，此时TCP流就会在一个新窗口中显示出来.

**了解专家信息**

整个网络中的TCP信息，都会被Wireshark的专家信息所记录，如丢包或者网络阻塞等。针对于每个协议的解析器，都会有一些专家信息，我们在分析的时候，可以通过专家信息窗口来查看使用该协议的数据包中一些特定状态的`错误`、`警告`以及`提示`等信息。

专家信息窗口可以通过菜单栏的**“Analyze”**->**“Expert Info”**来打开。

这个界面中一共有6个选项卡，分别表示的是：

**Error：**数据包里面或者解析器解析时出现的错误。 **Warnings：**不正常通信中的异常数据包。 **Notes：**正常通信中的异常数据包。 **Chats：**网络通信的基本信息。 **Details：**显示数据包的详细信息。 **Packet Comments：**数据包的描述信息。

#### 1.5 Wireshark 的命令行模式

tshark

## 二、协议篇

#### 2.1 ARP 协议数据分析

ARP (Address Resolution Protocol  ,地址解析协议) 用于将IP 地址解析为物理地址（MAC地址）。这里之所以需要使用MAC地址，是因为网络中用于连接各个设备的交换机使用了内容可寻址存储器（CAM，Coment Addressable Memory）。该存储器维护的**ARP表**列出了它在每一个端口的所有连接设备的`MAC地址`。

 当交换机收到了一个指向特定MAC地址的网络流量，它就会使用这个表，来确定应该使用哪一个`端口`发送流量。如果目标MAC地址是未知的，那么这个传输设备会首先在它的缓存中查找这个地址，如果没有找到，那么这个地址就需要通过在网络上额外的通信中解析了。



OSI模型将网络分为了 七层，而 IP 地址在第三层，也就是网络层，MAC地址位于数据链路层，也就是第二层。那么通过以太网发送IP数据包的时候，需要首先封装第三层和第二层的报头。但由于发送数据包时只知道目的 IP 地址，不知道其 MAC 地址，而又不能直接跨越第二、三层，所以需要地址解析协议，以确保通信的顺利进行。

ARP协议是在`RFC826`中定义的。RFC（Request for Comments）是定义各种协议实现标准的官方文档。

查看ARP缓存表：

```cmd
arp -a
```

，默认的ARP缓存表的有效期是`120秒`.

**分析ARP数据包**

![image-20210302170609317](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302170609317.png)

可以看到有很多 ARP 请求包，可以通过 Packet Details 面板，检查以太网头部信息来确定这个数据是不是一个真的广播包。

在 Frame 帧中知道该数据包的大小为 60 字节。

其次检查 `Ethernet` 部分的内容，会发现其目的地址是 `ff:ff:ff:ff:ff:ff` ,是广播地址，说明当前数据包会被广播到当前网段中所有设备上，而这个数据包中的以太网中的源地址就是本机 MAC地址。

![image-20210302171033242](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302171033242.png)

展开 ARP 请求的头部信息。按照顺序以此为

硬件类型，协议类型，硬件地址长度，协议长度，操作码（1 表示 ARP请求包），发送方 MAC 地址和IP地址，接收方MAC地址和IP地址，因为我们想获取的目的 MAC 地址还未知，所以都为 0 显示。

windwos 清空 arp 缓存，来抓 Arp 响应包：

```cmd
arp -d
```

![image-20210302171626117](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302171626117.png)

其实ARP响应的数据包和ARP请求的数据包很相像。不同之处表现在以下几点：首先，用于响应的数据包的`操作码`（Opcode）现在是2，表明这是一个用于`响应`的数据包；其次，发送方的MAC地址和IP地址变成了`目标`MAC地址和IP地址；最后，响应数据包中的内容都是可用的，也就是说我们已经获取了主机的MAC地址，那么接下来就可以正常通信了。

最后我们再讨论一个关于免费ARP（gratuitous ARP）的例子。由于网络中一个设备的IP地址是可以改变的，而MAC地址`不会改变`。那么一旦出现IP地址改变的情况，网络主机中缓存的IP和MAC地址映射就不再有效了。那么为了防止由于映射失败造成的通信错误，免费的ARP请求会被发送到网络中，强制所有收到它的设备使用新的IP以及MAC地址映射来更新缓存。通常，它发生在系统引导期间进行`接口配置`或`IP地址出现变化`的时候。

#### 2.2 Wireshark 眼中的IP协议

**存活时间 TTL**

存活时间（TTL， Time to live） 用于定义数据包的生存周期，也就是在该数据包被丢弃之前所能够经历的时间，或者能够经过的最大路由数目。这个值是在数据包被创建的时候设置的，而且通常每次发往一个路由器的时候会实现 **自减一** 的操作。一旦 TTL 的值变为了 0 ，那么这个数据包就会被丢弃。由于 TTL 的值在技术上是基于时间的，那么一个非常繁忙的路由器可能会将 TTL 值减去不止1 ，但是一般来说，我们还是可以认为一个路由设备在多数情况下只会将 TTL 的值减去1.

我们 抓取 icmp 包进行分析。

![image-20210302175521616](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302175521616.png)

展开 IP 的头部信息，

IP 版本为 4 ，IP头长度是 20 字节，总长度是 60 字节，TTL值是 128 。

**IP分片**

IP数据包的分片指的是将一个数据流分为更小的片段，是 IP 用于解决跨越不同类型的网络时可靠传输的一个特性。数据包的分片主要是基于 OSI 模型第二层的 数据链路层协议 所使用的**最大传输单元** （MTU 值，Maximum Transmission Unit）的大小，以及使用这些第二层协议的设备配置情况。在多数情况下，第二层所使用的数据链路层协议是以太网。而以太网的默认 MTU 是1500，那么以太网的网络上所能传输的最大数据包的大小就是 1500 字节，注意这里并不包括 14 字节大小的以太网头部本身。

当一个设备准备传输一个IP数据包时，会首先将这个数据包的大小和将要把这个数据包传出去的网络接口的 MTU 值进行比较，从而确定是否需要将这个数据包分片。如果数据包的大小 大于 MTU，那么这个数据包就会被分片。

步骤如下：

（1）设备将数据分为`若干个`可以成功进行传输的数据包。 （2）每个IP头的总长度域（Total Length）会被设置为每个分片的`片段长度`。 （3）`更多分片标志`（More fragments）将会在`数据流`的所有数据包中设置为1，最后一个数据包则为0。 （4）IP头中分片部分的`分片偏移`将会被设置。 （5）数据包被发送出去。

带片段的ICMP回显请求（1400B）响应（一侧MTU = 1000）。

![image-20210302181031278](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302181031278.png)

这里我们重点关注的是`更多分片标志`（More fragments）以及`分片偏移`（Fragment offset）。由于说在这个数据包中，更多分片标志被设置为了1，意味着这是一个分片数据包，并且接收设备还需要`等待接收`序列中的另一个数据包。而分片偏移被设置为了0，说明这个数据包是一系列分片偏移中的`第一个`。接下来查看一下第二个数据包的IP头：

![image-20210302181130673](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302181130673.png)

这个数据包并没有设定更多分片标志位，说明这是整个数据流的`最后一个分片`。并且其分片偏移被设定为 976 ,这2个分片之所以会被认为来自于同一个数据序列，是因为在Identification中，这三个数据包的值都是0xb5d0。

**IP数据包的捕获**

有很多方法可以捕获到IP数据包，比如我们打开一个网站，此时如果使用Wireshark就可以捕获到非常多的`IP数据包`。但是这样一来我们会捕获到非常多的诸如`DNS`、`HTTP`、`TCP`等协议的数据包，就不利于我们的分析。所以我们这里可以使用ping，这样就只会获取到`ICMP协议`的数据包。

所以我们这里可以使用ping，这样就只会获取到`ICMP协议`的数据包。首先我们可以在想要进行捕获的系统上打开Wireshark，选择菜单栏的**“Capture”**->**“Options”**，进行相应的设置即可。

我们也可直接 ping 发送一个自定义大小的数据包。

```cmd
ping www.baidu.com -l 3000
```

然后 筛选 

```txt
ip.addr==180.101.49.12
```

即可抓到 IP分片数据包

![image-20210302182445553](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302182445553.png)

#### 2.3 TCP与UDP详解

**了解TCP**

TCP （Transmission Control Protocol） 传输控制协议。在 RFC 793 中被定义。所有TCP通信都会使用 **源端口** 和 **目的端口** ，这些信息可以在每个 TCP 数据包的头部找到。而为了能够将数据传输到远程服务器或设备的特定应用中去，TCP数据包必须知道远程服务所监听的端口。如果想要尝试连接一个不同于所设置的端口，那么这个通信就会失败，一般来说，TCP通信的源端口并不重要，可以随机选择。而在使用 TCP 通信的时候，我们一共可以使用 65535 个端口。其中 1 至 1023 号端口属于标准端口组，往往是特定的服务所使用的，而 1024 至 65535 号端口则是临时端口，需要使用是，操作系用会在通信时以随机的方式或者采用一定的策略进行选择。

![image-20210302193733797](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302193733797.png)

此文件，可以看到这个数据包是从 145.254.160.237 法网 65.208.228.223 的，它的源端口是 3372，属于临时端口 ，由操作系统选取的，目的端口是 80 ，这是一个标准端口，这个端口通常提供给使用 HTP 的wen服务器。 

第二个数据包是从IP地址为65.208.228.223 发往145.254.160.237 的，除了IP地址相反之外，源端口和目标端口也是`相反的`：

![image-20210302194150942](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302194150942.png)

事实上，所有基于TCP的通信都以相同的方式工作：选择一个`随机的源端口`与一个已知的目`标端口`进行通信。在发出数据包之后，`远程设备`就会与源设备使用建立起的端口进行通信。

**了解TCP三次握手原理**

![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/03.jpg)

请大家注意的是，上图中的seq表示的是`请求`的序列号，ack表示`确认`序列号，SYN和ACK为`控制位`。 

**1、第一次握手** 在第一次握手建立连接时，客户端会向服务器发送`SYN数据包`（SYN=1，seq=x），并进入`SYN_SENT`状态，等待服务器的确认。

 **2、第二次握手** 第二次握手其实是分为两步来完成的，即SYN加上ACK，也就是请求和确认数据包。  （1）服务器收到了客户端的请求，向客户端回复一个确认信息（ack=x+1）。  （2）服务器再向客户端发送一个SYN包（seq=y）从而建立连接请求，此时服务器进入了SYN_RCVD状态。 

**3、第三次握手** 第三次握手时客户端收到服务器的回复，也就是SYN加上ACK数据包。此时，客户端也要向服务器发送确认数据包（ACK）。发送完毕之后，客户端和服务器就进入了ESTABLISHED的状态，从而完成了三次握手。那么接下来，客户端和服务端就可以开始传输数据了。

![image-20210302195023671](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302195023671.png)

需要说明的是，Wireshark为了让我们分析更加简便，引入了一个新的特性，可以自动将TCP数据包的序列号替换为`相对值`。但是这里我们不需要这个功能，我们希望看到`原始值`，可以选择菜单栏的**“Edit”**->**“Preference”**，展开窗口左侧的**“Protocols”**并选择**“TCP”**，然后取消勾选**“Analyze TCP sequence numbers”**，再单击**OK**即可。

![image-20210302195206444](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302195206444.png)

这个捕获文件的第一个数据包就是初始的`SYN数据包`，可以看到它的序列号是951057939。第二个数据包是从响应主机发出的`SYN/ACK响应`：

![image-20210302195445947](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302195445947.png)

这个数据包里面包含有这台主机的`初始序列号`（290218379），以及一个`确认号`（951057940），注意这个确认号比上一个数据包的序列号大1，因为这个域是用来表示主机所期望得到的下一个序列号的值，有助于数据包的`顺序传输`。 第三次握手的数据包是从亲求主机发出的`ACK数据包`：

![image-20210302195631484](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302195631484.png)

这个数据包正如所期望的那样，包含有之前数据包的确认号域所定义的序列号951057940，通过这个序列号，就可以知道数据的传输顺序没有问题。只要网络中存在有`TCP通信`，那么我们都会看到这个模式的三次握手。

**了解TCP的断开过程**

在TCP通信中，每次握手之后都会有断开的操作，一旦TCP通信结束，就会使用`4个数据包`以及一个`FIN`标志表明连接的结束。如下图所示：

![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/07.jpg)

TCP的断开步骤如下：

- 1、客户端向服务器发送一个设置了FIN和ACK标志位的TCP数据包，告诉服务器通信完成。
- 2、服务器收到客户端发来的数据包后，发送一个ACK数据包来回应客户端。
- 3、服务器再向客户端传输一个自己的FIN/ACK数据包。
- 4、客户端收到服务器的`FIN/ACK`数据包后，再向服务器发送一个ACK数据包，之后就结束通信过程。

![image-20210302200206731](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302200206731.png)

通过查看第一个数据包的标志位可以发现，IP地址为65.208.228.223的设备通过发送含有`FIN/ACK`标志位的数据包来开启TCP断开的过程。接下来目标设备使用了一个`ACK数据包`来确认收到了数据包，并且发送了一个FIN/ACK数据包。最后，IP地址为65.208.228.223的设备发送了最后的`ACK数据包`后，宣告TCP正式断开。那么这两个设备之间的TCP通信就已经结束了，如果想要再继续进行通信，则必须完成新的握手操作。

![image-20210302200359638](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302200359638.png)

**了解TCP的重置**

正常情况下，TCP通信的连接都会以TCP的`四次握手`断开。但是现实中，网络连接有时会出现断掉的情况。这有可能是遭受到了`网络攻击`，也有可能是出现了`配置错误`的情况。此时就需要使用设置了RST标志的TCP数据包，表示出现了`连接被异常终止`或`拒绝连接`的请求。

![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/09.jpg)

这个文件中的第一个数据包是从192.168.100.138发出的，并且尝试与192.168.100.1的80端口进行通信。但是由于目标主机并没有开启80端口，因此在第二个数据包中，就回应了一个`RST数据包`，告诉源主机80端口无法建立连接，那么通信也就终止了。由此可见，RST数据包可以在通信序列的开始或者在主机通信的过程中，将通信终止。

**UDP数据包分析**

UDP（User Datagram Protocol） ,用户数据包协议，是现代网络中最常用的另外一种第四层的协议。如果说TCP是为了满足带有内在错误检测的`可靠数据传输`，那么 UDP 主要是为了提供高速的传输。出于这个原因，UDP是一种尽力服务，通常会被称为`无连接协议`。一个无连接协议不会正式地建立和结束主机之间的连接，也不会像 TCP 那样存在握手和终止的过程。

无连接协议意味着它是一种不可靠的服务，这将使得UDP的流量一点都不稳定。但依赖于UDP的协议通常都会有其它的可靠性服务，或者使用`ICMP`的一些功能来保证连接更可靠一些。比如，应用层协议`DNS`和`DHCP`需要高度依赖数据包在网络上的传输速度，因此需要使用`UDP协议`，并利用它们自身的错误检查以及重传计时来保证数据的正确传输。

![image-20210302201228982](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302201228982.png)

可以看到，这个捕获文件是由DNS形成的。而UDP的内容也很简单，包含有`源端口`、`目标端口`、`数据报`的长度以及校验和等信息。

需要强调的是，UDP并不关心传输的可靠性，所以任何使用UDP的应用在必要的时候都需要采取特殊的步骤，从而保证传输的`可靠性`。

**TCP与UDP数据包的捕获**

最后我们再来尝试在网络上捕获真实的TCP与UDP数据包进行分析。这里我们可以采用上次课程中所讲过的方法，专门捕获`TCP数据包`。比如这里我们可以利用浏览器打开“i春秋”主页，并进行`抓包`，生成Lab8-6.pcapng这个文件。

由于捕获的数据包比较多，因此我们可以首先进行筛选。比如可以通过**“Edit”**->**“Find Packet”**，在弹出的对话框中以String的形式搜索字符串“ichunqiu”，那么可以找到一个`HTTP协议`的数据包。根据这个，我们就可以知道源IP地址以及目标IP地址，于是接下来就可以利用筛选器，输入`筛选条件`：

```
ip.addr==172.21.79.153 && ip.addr==61.135.185.105
```

那么剩下的就是这两个IP地址之间的流量了。下面我们尝试寻找TCP的`三次握手`，当然这可以根据数据包中seq以及ack的值进行匹配，比如4号数据包中seq的值为3958928431，而17号数据包的ack值为3958928432，于是就可以知道这两个数据包分别是`第一`和`第二次`TCP握手。而第18个数据包的seq的值也是3958928432，那么其实我们就已经找到了TCP的三次握手。 或者我们可以通过着色的形式将这些相关的数据包高亮显示。

使用鼠标右键单击4号数据包，依次选择**“Colorize Conversation”**->**“TCP”->“Color 1”**（可按照自己的喜好选择颜色），于是Wireshark中的数据包就得到了高亮显示：

[![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/11.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51435/11.jpg)

很明显，第4、17以及18号数据包就是TCP的三次握手。然后我们可以把这三个数据包导出来，选择**“File”**->**“Export Specified Packets”**，在弹出的对话框中给文件起一个名字，我这里是`Lab8-6-handshake.pcapng`，之后在**“Range”**后面的输入框中填上`“4,17,18”`，选择**“保存”**，那么只包含有三个数据包的捕获文件就生成了。

或者我们也可以在想要保存的数据包上单击鼠标右键，选择**“Mark Packet(toggle)”**，然后在导出窗口中选择**“Marked packet”**即可。

#### 2.4 TCP中也有一个窗口

**TCP知识的补遗**

在讲解TCP窗口的知识之前，关于TCP数据包还有几个知识点是需要补充讲解一下的。这里我们打开实验文件Lab9-1.pcap：

![image-20210302212644882](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/image-20210302212644882.png)

TCP进行`有序的`数据传输，因此每个数据段都要标上一个序列号，也就是 `seq` 的值，这样当接收方收到乱序的数据包时，就可以根据这个值进行 **重新排序**了。这里我们并不知道seq的起始值是怎么计算的，但是必须理解这个值的增长方式。

如上图所示，1号数据包Seq的值为4131969696，这个数据包的长度，也就是Len的值为1448，那么2号数据包的Seq的值就应当是4131969696+1448=4131971144，与2号数据包的Seq值是吻合的。可见，Seq的值是依据上一个数据包的`Seq值`加上长度得来的。这个Seq值是由这两个数据包的`发送方`，也就是10.32.106.159维护的。

由于TCP是`双向的`，一个连接中的双方都可以是数据的发送方，所以双方各自都会维护一个`Seq值`，上图中的1、2、4、5号数据包有自己的Seq值，而3号和6号数据包的Seq值则是由10.32.106.62维护的。3号数据包Seq的值为735349110，Len的值为0，所以6号数据包的Seq值依旧是735349110。

这里需要注意的是，比如1号数据包的Len的值为1448，但是这个长度是不包括TCP头的长度的。而3号和6号数据包的Len的值尽管为0，但其实这里面是包含有TCP头的。`TCP头部`包含有丰富的信息，因此大家千万不要误以为Len的值是0就没有意义，其实Len是0的情况还是很常见的。

然后我们回过头再看一下2号数据包。这里它发送了“Seq=4131971144，Len=1448”的数据包，那么当对方收到这个数据包之后，应当回复的`确认号`，也就是Ack的值就应该是4131971144+1448=4131972592，意味着已经收到了4131972592之前的所有字节数据。而我们看到3号数据包的Ack的值与此是吻合的，说明`网络传输`是正常的。事实上，接收方所回复的Ack的值其实就是发送方的下一个Seq的值，所以我们可以看到4号数据包的Seq的值也等于4131972592。

这里需要注意的是，3号数据包是对2号数据包成功接收的`确认`，但是为什么没有收到1号数据包的确认数据包呢？其实3号数据包在确认4131972592的时候，就说明了序列号小于4131972592的所有字节都收到了，也就相当于确认了1号数据包里面所包含的数据，可见TCP的确认是可以`累加的`。

在TCP连接中，因为双方都可以是`接收方`，所以他们各自除了会维护各自的`Seq值`以外，还会维护各自的Ack的值，由于在第3和第6号数据包中，10.32.106.62并未发送任何实质性的数据，也就是Len的值为0，于是接收方，也就是10.32.106.159的`Ack的值`就没有任何变化。

这些参数对于我们学习`网络分析`是很重要的。因为一旦将这些原理和概念了然于胸，那么接下来对于TCP的深入学习，理解TCP更加深层次的特性就会有事半功倍的效果。比如如果数据包出现了乱序的情况，那么接收方只要依据Seq的值`从小到大`进行排列就可以了，这样就保证了数据传输的有序性。或者当出现了丢包的情况，接收方只要通过前一个`Seq+Len`的值再减去下一个`Seq的差`，就可以判断丢了哪些包。可以举一个例子，假设10.32.106.62并未收到2号数据包，那么这里可以先计算一下1号数据包的Seq+Len的值，即4131971144，再减去下一个数据包的Seq，结果是1448，那么就可以知道有Len=1448的数据包丢失了。那么这就保证了TCP数据传输的`可靠性`。

**了解TCP窗口的原理**

在 TCP 协议中，实现了滑动窗口的机制，可以检测什么时候发生了数据包的丢失，并且调整数据的传输速率以避免丢失情况的加剧。滑动窗口机制的利用数据接收方的接收窗口来对数据流进行控制。

接收窗口是数据接收方自己依照实际情况而定下来的值，保存在TCP的头部信息中，这个值告诉了发送方自己希望在**TCP缓冲空间**中保存多少数据。这个**缓冲空间**是数据可以向上传递到等待处理数据的应用层协议之前的临时存储空间。所以，发送方一次只可以发送 windwos size 所指定的数据量。而为了传输更多的数据，接收方必须要发送确认数据包，表示之前的数据已经接收到了。同时也必须要处理占用着TCP缓冲区的数据，从而清空缓冲区，已接收新的数据。

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51437/03.jpg)

在上图中，服务器一开始声明的窗口大小是5000字节。客户端发送了2000字节，接下来又发送了2000字节，于是就剩下了1000字节的缓存空间。服务器发现如果客户端再这样发送数据，那么自己的缓冲空间就会被塞满，那么就会导致数据包的丢失。为了避免这个问题，服务器向客户端发送了一个确认数据包，里面也包含了新的窗口的大小为1000字节。于是，客户端就会`减少`发送的数据量，服务器可以按照`能够接受的速率`处理缓冲区的内容，保证网络的健康运行。那么当服务器处理完缓冲区中的数据，就可以考虑利用`确认数据包`，指定更大的窗口大小。

**了解TCP的零窗口**

在有些情况下，服务器可能无法处理`客户端`发送的数据，比如服务器出现故障等的情况。此时仅仅减小窗口的大小是不行，而需要将接收窗口的值直接设置为`零值`。也就是通过ACK数据包告诉客户端，窗口的大小是0，让客户端停止所有的`数据传输`，但是仍然会通过`“保活数据包”`来保持与服务器的连接。客户端会`周期性`地发送这样的数据包，以检测服务器的接收窗口的状态。一旦服务器排除了故障，能够再次处理数据，那么就会向客户端发送一个非零的窗口大小以`恢复通信`。下图展示了这个原理：

![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/04.jpg)

在上图中，服务器开始用5000字节的窗口接收数据。在从客户端接收到了两次2000字节的数据包之后，服务器出现了问题，无法再次处理来自客户端的数据。那么此时服务器就会发送一个`ACK数据包`，告诉客户端，窗口大小变成了0。于是客户端就`暂停`了数据的传输，接下来就给服务器发送`保活数据包`。在服务器解决了自身的问题之后，就会给客户端发送一个窗口大小非零的数据包，告诉客户端新的窗口大小为1000字节，于是客户端就可以继续发送数据了。

**TCP滑动窗口数据包分析**

在有些情况下，服务器可能无法处理`客户端`发送的数据，比如服务器出现故障等的情况。此时仅仅减小窗口的大小是不行，而需要将接收窗口的值直接设置为`零值`。也就是通过ACK数据包告诉客户端，窗口的大小是0，让客户端停止所有的`数据传输`，但是仍然会通过`“保活数据包”`来保持与服务器的连接。客户端会`周期性`地发送这样的数据包，以检测服务器的接收窗口的状态。一旦服务器排除了故障，能够再次处理数据，那么就会向客户端发送一个非零的窗口大小以`恢复通信`。下图展示了这个原理：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51437/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51437/04.jpg)

在上图中，服务器开始用5000字节的窗口接收数据。在从客户端接收到了两次2000字节的数据包之后，服务器出现了问题，无法再次处理来自客户端的数据。那么此时服务器就会发送一个`ACK数据包`，告诉客户端，窗口大小变成了0。于是客户端就`暂停`了数据的传输，接下来就给服务器发送`保活数据包`。在服务器解决了自身的问题之后，就会给客户端发送一个窗口大小非零的数据包，告诉客户端新的窗口大小为1000字节，于是客户端就可以继续发送数据了。

**步骤6：TCP滑动窗口数据包分析**

下面我们通过分析几个实际的例子来看一下TCP的`滑动窗口机制`。打开实验文件Lab9-2.pcap：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51437/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51437/05.jpg)

这里我们主要关注的是`Window Size`的值，这个值可以通过查看数据包的Info列得出。可以发现，在前三个数据包中，这个值是在不断地缩小的。也就是从第一个数据包的8760减小到5840，再减小到2920，之后变成了0。窗口不断减小，是主机`延迟增加`的典型表现。此时注意一下Time列的值，可见窗口的缩小是在`极短的时间`内发生的。

第四个数据包是由数据的接收方发往数据的发送方的，目的是告诉对方自己不再接收任何数据。当自己的缓冲区数据处理完后，就告诉数据的发送方，自己的窗口大小变为了64240，可以继续接收数据了，于是接下来就恢复了数据的传输。 接下来我们再分析一下**Lab9-3.pcap**文件。可以看到，第一个数据包是一个正常的HTTP数据包，但是紧接着的2号数据包却是一个`通知窗口为0`的数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51437/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51437/06.jpg)

与上一个实验文件所不同的是，接下来数据的接收方并没有发送`窗口恢复`的通知。所以数据的发送方只能不断地发送保活数据包来进行检查，可以看到捕获文件中的第3、5、7号数据包都是`保活数据包`，而数据接收方的回应全都是窗口值为0。 如果大家的Wireshark并没有标记出保活数据包，那么可以选择菜单栏的**“Edit”**->**”Preferences”**->**”Protocols”**->**”TCP”**，勾选**“Analyze TCP sequence numbers”**即可：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51437/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51437/07.jpg)

那么此时的`零窗口数据包`以及`保活数据包`就全都标记出来了。

#### 2.5 TCP重传技术的研究

**TCP重传原理**

在TCP重传的理论中，重传计时器是用于决定是否有必要进行数据包重传的一个主要机制。重传计时器维护着一个叫做重传超时（Retransmission timeout，RTO）的值。在使用TCP进行数据包的传送时，重传计时器就会被启动。当收到数据包的ACK，也就是确认数据包时，计时器就会停止。从发送数据包到接收到确认数据包的时间，被称作往返时间（Round-trip time，RTT）。我们将若干个往返时间求和并计算平均值，就可以得出最终的RTO值。

但是在最终计算出RTO值之前，数据的传输操作将会一直依赖于默认的RTT值。这个设置用于主机之间的初始通信，并基于接收到的数据包的RTT进行调整，从而形成真正的RTO值。

一旦RTO值被确定下来，重传计时器就被应用于每个传输的数据包，从而确定数据包是否丢失，如下图所示：

![img](https://static2.ichunqiu.com/icq/resources/fileupload/51439/01.jpg)

当数据包发送出去，但是接收方没有发送TCP ACK数据包时，发送方就假设原来发送的数据包并没有发送到目标主机，认为它丢失了，于是就进行重传。重传之后，RTO的值翻倍；如果在到达极限值之前依旧没有收到ACK数据包，那么就会进行第二次重传。如果还是没有收到ACK，那么RTO的值就会再次翻倍。那么每次的重传，都会导致RTO的值翻倍，直至收到ACK数据包，或者发送方达到配置的最大重传次数为止。当然我这里所说的每次进行翻倍，是为了便于大家的理解，实际上在计算RTO的时候，是需要几个公式的，这里不做深入研究。一般来说，Windows操作系统会重传5次，而Linux则为15次。这个次数是可以进行修改的。

下面我们来研究一下Lab10-1.pcap这个实验文件，这个文件中包含了TCP重传的情况。可以看到，第一个数据包是一个正常的TCP PSH/ACK数据包，其中的PSH表示Push操作，也就是指当数据包到达接收端后，立刻传送给应用程序，而不是在缓冲区中排队。那么接下来，在正常的情况下，当接收端接收到第一个数据包之后，往往很快就可以看到用于响应的TCP ACK数据包。但是这里的第二个数据包却是一个TCP Retransmission数据包，表明这是一个重传：

![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/02.jpg)

而且接下来的几个数据包也都是重传数据包。这里请大家注意的是，重传数据包和第一个数据包相比，它们的Data区段，也就是所传输数据的主体内容，是完全一致的。如果我们展开查看Packet Details面板中的TCP，还可以发现相应的RTO的值等信息，并且这个RTO与每个数据包的发送时间是相吻合的，呈指数增长。

**TCP的快速重传**

如果接收方接收到了乱序的数据包，就发送重复的TCP ACK数据包。TCP在其头部使用序号和确认字段，以确保数据被可靠接收并以发送的顺序进行重组。我们上次课说过，Seq序列号可以帮助数据进行有序的传输。

如果接收方遇到不符合顺序的序列号，就知道数据包丢失了。那么为了正确地重组数据，接收方必须要得到丢失的数据包，因此接收方会发送一个包含丢失数据包序列号的ACK数据包，这样发送方就可以知道应该发送哪一个数据包了。以下图为例：

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51439/03.jpg)

如果发送方收到3个来自接收方的重复ACK时，发送方就会假设这个数据包确实在传输的过程中丢失了，于是就立刻发起快速重传的机制。一旦触发了快速重传，其它所有正在传输的数据包都要先暂停发送，直到把丢失的数据包发送出去为止。为什么要规定凑满三个重复ACK数据包呢？我的理解是，网络数据包有些时候在传输的过程中会出现乱序的情况，乱序的数据包一样会触发重复ACK数据包，但是由于出现乱序而重传没有必要。由于一般的乱序的距离不会相差太大，比如3号数据包也许会到5号数据包的后面，但是不太可能跑到7号数据包的后面，所以限定成3个或者以上，就可以在很大的程度上避免由于乱序而导致的快速重传。

这里我们分析一下实验文件Lab10-2.pcap：

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51439/04.jpg)

我们首先看一下第一个数据包，这个TCP ACK数据包是从数据的接收方发往数据的发送方的，是对前一个数据包的确认。从Ack的值可以知道，接收方目前已经收到了1之前的所有数据，而这个值也应当是接收的下一个数据包的Seq号。然后看一下第二个数据包：

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51439/05.jpg)

可以发现，这个数据包的Seq的值是10945，并不是我们希望看到的1，这就说明了数据在传输的过程中出现了丢包的情况。当接收方发现这个问题之后，就会向发送方发送一个重复的ACK数据包：

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51439/06.jpg)

接下来的第4个数据包依旧是发送方所发送的数据，并且依旧是错误的Seq号，于是接收方发送第二个重复ACK数据包，接下来发送方又发送了一个错误的数据包，于是接收方再回复一个重复ACK数据包。

由于发送方收到了三个重复的ACK数据包，那么就会停止所有数据的发送工作，并重新发送丢失的数据包，也就是第8个数据包的内容：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51439/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51439/07.jpg)

可以看到，这里已经标出了这个数据包就是一个快速重传数据包，其大小为1368。那么下一个数据包就是对这个快速重传数据包的回应，从Ack=1369可以知道，已经接收到了1369之前的所有数据。

**多个数据包丢失的情况**

最后我们再讨论一个比较复杂的情况，也就是丢失了多个数据包的情况。假设发送方一共发送了8个数据包，但是其中的2号和3号数据包丢失了，而1、4、5、6、7、8号数据包都抵达了接收方，并且触发了Ack 2，也就是通知发送方，没收到2号数据包。对于发送方来说，只能通过Ack 2知道2号数据包丢失了，但是并不知道还有哪些数据包丢失了。那么在重传了2号数据包之后，接下来应该传哪一个呢？有以下三种方案： 方案1：把3、4、5、6、7、8号数据包重传一次。这是最简单直接的办法，但是这个丢包的后果导致了多个数据包被重传，效率是非常低的。其实早期的TCP协议就是这样处理的。 方案2：接收方收到重传过来的2号包之后，会回复一个Ack 3，这样发送方就可以知道3号数据包也丢失了，于是传送3号包。这样当接收方收到重新传送过来的3号包之后，由于所有的数据包都收到了，就回复一个Ack 9，那么发送方就可以从9号数据包开始发送数据了。这个方案被称为NewReno，在RFC2582和RFC3782中被定义。NewReno的方法虽然说比较完善，但是在丢包量很大的时候，就需要花费多个往返时间来重传所有丢失的数据包。 方案3：接收方在请求重传2号包的时候，顺便把收到的数据包号告诉发送方。所以网络上数据的传输过程因该是这样的： 在收到4号数据包时，告诉发送方已经收到4号，但是2号没收到。 在收到5号数据包时，告诉发送方已经收到4、5号，但是2号没收到…… 这样一来，发送方就可以对丢包的细节了如指掌，在快速重传了2号数据包之后，它可以接着传3号，然后再传9号数据包。这种方案被称为SACK，在RFC2018中被定义。

这里我们依旧看一下实验文件Lab10-2.pcap，查看一下它的第3个重复的ACK数据包，在Packet Detail面板中，展开TCP中的Options，查看一下SACK的内容：

[![Alt text](https://gitee.com/luo_fan_1/yanmie-art/raw/master/img/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51439/08.jpg)

可以看到，SACK后面的值为5473-15049，表示序列号为5473到15049的数据已经接收到了，结合Ack=1，那么发送方就知道序列号为1到5472的数据没收到，于是接下来就发送这些数据。

#### 2.6 用途广泛的ICMP协议

**Echo请求与回应**

对于ICMP协议来说，我们接触最多的就是ping 了。但是很多人对ping有个误解，以为它是一个命令，但事实上，ping是一款用于检测一个设备可连接性的工具，ping这款工具用于发送ICMP echo请求数据包。正因为如此，学习`ICMP协议`对于网络安全具有极其重要的意义。因为ICMP协议本身的特点就决定了它非常容易被用于攻击网络上的路由器和主机。比如，用户可以利用操作系统规定的ICMP数据包的最大尺寸不超过64K这个规定，向网络上的主机发起Ping of Death攻击，它属于一种拒绝服务（DDoS）攻击。因为当ICMP数据包的大小超过64K的时候，目标主机就有可能出现内存分配的错误的情况，导致TCP/IP堆栈崩溃，使得主机死机。另外，向目标主机长时间、连续、大量地发送`ICMP数据包`，也会最终使系统瘫痪。大量的ICMP数据包会形成“ICMP风暴”，使得目标主机耗费大量的CPU资源来处理。

下面我们来实际分析一个捕获文件。这个文件是我们在讲解第6课，也就是IP协议的时候，利用ping功能捕获的数据包（Lab11-1.pcapng）：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51441/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51441/01.jpg)

首先需要强调的是，在分析ICMP数据包的时候，我们需要重点关注的是ICMP头部的Type以及Code的内容。Type表示ICMP消息基于`RFC规范`的类型或分类。Code表示ICMP消息基于RFC规范的子类型。看一下第一个数据包，它显示了主机192.168.147.129在给172.21.79.153发送数据包。ICMP头部中的Type的值是8，Code值是0，说明这是一个echo请求数据包，Wireshark已经帮我们解析出来了。其实这是一个简单的`ICMP数据`包，使用IP发送，所包含的数据很少。除了指定的类型、代码以及校验和，这里还有序列号用于匹配请求和响应，并且在可变域中包含有一串随机字符串。

接下来我们再分析一下第二个数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51441/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51441/02.jpg)

这个数据包是对我们请求的响应。在它的`ICMP头部`中，类型和代码的值都是0，表示这是一个echo响应。由于第二个数据包的序列号和第一个数据包可以相匹配，于是就可以确定它和第一个数据包是对应的。并且还可以发现，在Data的部分，这个数据包有着和第一个数据包相同的字符内容。当这个数据包被成功接收后，ping就成功了。

ICMP的echo请求使用的字符串可能会引起攻击者的兴趣，攻击者可能会使用这段内容来推测设备所使用的操作系统。并且攻击者可能在这个地方放置一些数据位作为反向连接的手段。

**步骤3：路由跟踪**

路由跟踪功能用来识别一个设备到另一个设备的网络路径。在一个简单的网络上，这个网络路径可能只经过一个路由器，甚至一个路由器也不经过。但是在复杂的网络中，数据包可能会经过数十个路由器才会到达最终的目的地。对于网络通信检修来说，确定数据包从一个地方到另一个地方所走的路径是非常重要的。

想要进行路由跟踪，我们可以在命令提示符中使用tracert功能，它就是利用了`ICMP协议`的，通过其跟踪结果，我们就可以画出数据包所走的路径。这里我们可以分析一下Lab11-2.pcap实验文件：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51441/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51441/03.jpg)

首先看一下第一个数据包，可以发现它与我们刚才分析的echo请求很相像。这个数据包是从IP地址为192.168.100.138到4.2.2.1的简单的echo的请求，并且ICMP数据包头部的每一部分都与echo请求数据包相同。但是需要我们注意的是，这个数据包的IP头中的`TTL`的值为1，这也就意味着这个数据包会在它所遇到的第一个路由器的地方被丢弃。由于目标地址4.2.2.1其实是一个互联网的地址，我们就会知道源设备和目标设备之间肯定至少存在一个路由器，因此这个数据包不会到达目的地。

下面再看一下第二个数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51441/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51441/04.jpg)

这个数据包其实就是在前往目的地的路径上，由第一个路由器发回的响应。由于第一个数据包到达192.168.100.1后，TTL的值变成了0，因此就不能够继续传输，此时路由器就回复了一个ICMP响应。这个数据包的类型是11，代码是0，告诉我们这个数据包的TTL在传输中超时，所以目标地址不可达。

这里请大家注意的是，在`ICMP`的结尾部分包含了原echo请求的IP头和ICMP数据的拷贝。因此这个数据包也被叫做ICMP双头包，表示包含有两个ICMP的包头信息。双包头信息在网络故障检修的时候会非常有用。

继续往下分析可以发现，在第七个数据包之前，又发送了两次TTL的值为1的数据包。而第七个数据包的TTL的值变成了2。这就保证了这个数据包会到达第二跳的路由。但是即便TTL的值变成了2，从下面的数据包来看，它也是无法到达目的地，直至TTL的值增长到9，这个数据包才到达了目的地。

当然我们在未来的课程中还会遇到`ICMP`协议，还会研究它的不同的功能，因此说ICMP是一个用途广泛的协议。

**步骤4：ICMP数据包的抓取**

最后我们再来研究一下ICMP数据包的抓取。最常用的，是使用ping工具进行捕获，关于这个我们已经在第六课中演示过了。所以这里我们可以尝试使用tracert来尝试抓取。在虚拟机中，打开命令提示符，输入`tracert`加上目标IP地址（主机IP）：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51441/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51441/05.jpg)

然后看一下Wireshark的抓取结果（Lab11-3.pcapng）：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51441/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51441/06.jpg)

可以看到，这里也出现了由于TTL的值不够，而出现的数据包不可达的情况。

至此，本系列课程的所有通用的底层网络协议的分析就到这里，我们在未来的实际问题的分析中，会经常遇到诸如IP、TCP、UDP、以及ICMP这样的底层协议，因为它们是一切网络通信的基础，对我们未来的分析至关重要。那么从下次课程开始，我们会开始研究一些高级的、基于应用层的网络协议。

#### 2.7 容易被忽略的DHCP协议

DHCP( Dynamic Host Configuration Protocol, 动态主机配置协议)，是一个局域网的网络协议，使用 UDP 协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，在 RFC 2131 中有详细的描述。DHCP 有3个端口，其中 UDP67 和 UDP68 为正常的 DHCP 服务端口，分别作为 DHCP Server 和 DHCP Client 的服务端口；546 号端口用于 DHCPv6 Client ，而不用于 DHCPv4，是为 DHCP Failover 服务，这是需要特别开启的服务，DHCP Failover 是用来做“双机热备”的。

在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的 IP 地址，而不用在每台计算机上单独配置固定的 IP 地址。

DHCP 使用了 **租约** 的概念，或称为计算机 **IP 地址的有效期**。租用时间是不定的，主要取决于用户在某地联接 Internet 需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。通过较短的租期，DHCP 能够在一个计算机比可用 IP 地址多的环境中动态地重新配置网络。DHCP 支持为计算机分配静态地址，如需要永久性 IP 地址的 Web 服务器。

DHCP 和另一个网络 IP 管理协议 `BOOTP` 类似(`BOOTP` 是 DHCP 的前身)。目前两种配置管理协议都得到了普遍使用，其中 DHCP 更为先进。某些操作系统，如 Windows NT/2000，都带有 DHCP 服务器。DHCP 或 BOOTP 客户端是装在计算机中的一个程序，这样就可以对其进行配置操作。

DHCP的工作原理 DHCP的前身是`BOOTP协议（Bootstrap Protocol）`，属于TCP/IP的应用层协议。BOOTP协议当初被创建出来给连接到网络的设备自动分配地址。直到后来才被更加复杂而完善的DHCP协议所取代。DHCP在网络配置方面非常重要，特别是当一个网络的规模较大时，使用DHCP可以极大地减轻网络管理员的工作量。另外，对于移动设备来说，由于使用的环境会经常改变，那么它所处的网络IP地址也就可能随时变动。如果每次都需要通过手工修改来设置它们的IP地址，使用起来就会非常麻烦。那么此时，就可以使用DHCP来减轻负担。

DHCP 报文共有 **`8`** 种，分别用于不同的功能，详解如下：

| 报文类型     | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| DHCPDISCOVER | DHCP 客户端请求地址时，并不知道 DHCP 服务器的位置，因此 DHCP 客户端会在本地网络内以广播方式发送请求报文，这个报文成为 Discover 报文，目的是发现网络中的 DHCP 服务器，所有收到 Discover 报文的 DHCP 服务器都会发送回应报文，DHCP 客户端据此可以知道网络中存在的 DHCP 服务器的位置。 |
| DHCPOFFER    | DHCP 服务器收到 Discover 报文后，就会在所配置的地址池中查找一个合适的 IP 地址，加上相应的租约期限和其他配置信息（如网关、DNS 服务器等），构造一个 Offer 报文，发送给用户，告知用户本服务器可以为其提供 IP 地址。（ 只是告诉 Client可以提供，是预分配，还需要 Client 通过 ARP 协议检测该 IP 是否重复） |
| DHCPREQUEST  | 客户端发给服务端，用来(1)从众多服务器的 `DHCPOFFER` 报文中选取一个最先接收到的，摒弃其他的 DHCP 服务器；(2)系统重启后确认之前分配的 IP 是否可用；(3)租期续约（在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，发送广播Request报文续延租期。） |
| DHCPACK      | 服务端发给客户端，服务端根据收到的 Request 报文中携带的用户 MAC 地址来查找有没有相应的租约记录，如果有则发送 `DHCPACK` 报文作为回应，通知用户可以使用分配的 IP 地址 |
| DHCPNAK      | DHCP 服务器收到 `Request` 报文后，没有发现有相应的租约记录或者由于某些原因（租约到期、客户端移动到别的字网）法正常分配 IP 地址，则发送 `NAK` 报文作为回应，通知用户无法分配合适的 IP 地址 |
| DHCPDECLINE  | DHCP 客户端收到 DHCP 服务器回应的 `DHCPACK` 报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送 `Decline` 报文，通知服务器所分配的 IP 地址不可用 |
| DHCPRELEASE  | 当用户不再需要使用已分配的 IP 地址时，就会主动向 DHCP 服务器发送 `Release` 报文，告知服务器用户不再需要分配 IP 地址，DHCP 服务器会释放被绑定的租约 |
| DHCPINFORM   | DHCP 客户端如果需要从 DHCP 服务器端获取更为详细的配置信息，则发送 `Inform` 报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送 `DHCPACK` 报文回应 DHCP 客户端 |

https://www.dazhuanlan.com/2020/02/27/5e57b1701492e/

#### 2.8 不可或缺的DNS协议

**DNS协议解析过程**

DNS的服务采用服务器/客户端`（C/S）`的方式工作。当客户端程序要通过一个主机名称访问网络中的一台主机时，它首先需要得到这个主机名称所对应的IP地址。因为IP数据包中允许放置的是目标主机的IP地址，而不是主机的名称。可以从本机的hosts文件中得到主机名称所对应的IP地址，但如果hosts文件不能够解析该主机的名称，则只能通过向客户机所设定的DNS服务器进行查询了。不过本机的hosts文件可能会被造假，从而为黑客打开方便之门。

下面以`www.ichunqiu.com`域名为例讲解DNS解析的过程：

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/01.jpg)

由上图可知DNS名称解析的过程为

1、客户计算机向本地域名服务器发送了一个查询请求，请求查询域名为[www.ichunqiu.com的IP地址。](http://www.ichunqiu.xn--comip-ry2iwd4320a./)

2、本地域名服务器查找自己保存的记录，看能否找到这个被请求的IP地址。如果本地域名服务器有这个地址，就会把这个地址返回给客户计算机。如果本地域名服务器没有这个地址，则会发起查找地址的过程。本地域名服务器发送请求给根域名服务器，询问[www.ichunqiu.com的IP地址。](http://www.ichunqiu.xn--comip-ry2iwd4320a./)

3、根域名服务器无法提供这个地址，但是会将com的名称服务器的地址返回给本地域名服务器。

4、本地域名服务器再向com域服务器发送查询地址的请求。

5、com域服务器无法提供这个地址，就将ichunqiu.com域名服务器的地址发送给本地域名服务器。

6、本地域名服务器再向ichunqiu.com域名服务器发送地址查询的请求。

7、ichunqiu.com域名服务器找到了[www.ichunqiu.com的IP地址，就将这个地址发给本地域名服务器。](http://www.ichunqiu.com的IP地址，就将这个地址发给本地域名服务器。/)

8、本地域名服务器会将这个地址发给客户计算机，并将这个IP地址保存到缓存中。那么接下来，客户计算机就可以访问[www.ichunqiu.com了。](http://www.ichunqiu.xn--com-3h9d./)

以上就是DNS域名解析的过程，在这个过程中通常会用到两种查询方式，分别是递归查询和迭代查询：

##### 1、递归查询

客户计算机向本地域名服务器的查询一般采用的是递归查询。如果客户机所询问的本地域名服务器无法提供被查询域名的IP地址，那么本地域名服务器就会以DNS客户的身份，向其它根域名服务器继续发出查询请求的报文。

##### 2、迭代查询

本地域名服务器向根域名服务器的查询通常采用的是迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求的报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器“下一步应该向哪个域名服务器进行查询”。然后本地域名服务器就进行后续的查询。

**DNS查询数据包分析**

里我们结合Lab13-1.pcap文件来分析一下DNS的查询：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/02.jpg)

首先看一下第一个数据包。它是由IP地址为`192.168.0.114`发往`205.152.37.23`的53号端口的。53号端口也正是系统默认的DNS查询的端口。并且我们还可以知道，DNS其实是基于UDP协议的。

这里我们看一下DNS头部的`Flags`区段。可以发现这个数据包是一个典型的DNS请求。再展开查询区段，从Name的值可以知道客户端其实是想查询wireshark.org的网络地址。接下来的Type:A表示域名类型为A，也就是主机地址。并且地址的类型是IN，也就是互联网地址。那么其实这个数据包就是在向本地域名服务器询问wireshark.org的IP地址是什么。下面看一下第二个数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/03.jpg)

这个数据包是对第一个数据包的回应，从标识码的值也可以知道它与第一个数据包是对应的。在 Flags区段可以看到这是一个响应数据包，并且允许必要的递归。接下来的Questions以及Answer RRs的值都是1，说明接下来的区段会包含一个询问和一个回答。询问的内容与上一个数据包一致，回答的内容就是对询问的问题做一个回应。也就是回复了wireshark.org的IP地址是128.121.50.122。客户计算机获取了这个回应信息，就可以开始构建IP数据包，并与wireshark.org进行通信了。

**dns递归查询**

这里我们研究一下DNS的递归数据包。实验文件`Lab13-2.pcap`是从客户端捕获的两个DNS数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/04.jpg)

首先，第一个数据包是从客户端172.16.0.8发往DNS服务器172.16.0.102的初始查询。展开这个数据包的DNS区段，可以发现这是一条用于查找域名为www.nostarch.com的标准查询，并且在Flags区段中还看到了期望递归的标志。

这里我们研究一下DNS的递归数据包。实验文件`Lab13-2.pcap`是从客户端捕获的两个DNS数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/04.jpg)

首先，第一个数据包是从客户端172.16.0.8发往DNS服务器172.16.0.102的初始查询。展开这个数据包的DNS区段，可以发现这是一条用于查找域名为www.nostarch.com的标准查询，并且在Flags区段中还看到了期望递归的标志。

仅仅在客户计算机进行抓包分析，我们只能知道成功获取了IP地址，并不知道这个IP地址的查询过程是否进行了递归的操作。因此这里我们需要研究一下在服务器端获取的实验文件`Lab13-3.pcap`。这个文件包含有在查询开始时，在本地DNS服务器上捕获到的数据包。这里的第一个数据包和我们之前捕获文件中的初始查询相同。

此时，DNS服务器接收到了这个查询数据包，检索本地数据库之后，发现自己并不知道关于所查询域名的IP地址。由于这个数据包被设置了期望递归，那么我们在第二个数据包中就可以看到这个DNS服务器为了获取IP地址，于是就向其它的DNS服务器进行查询：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/06.jpg)

在这个数据包中，位于172.16.0.102的DNS服务器向位于4.2.2.1的DNS服务器发起了查询请求，这个服务器就是本地DNS服务器所设定的要转发上行请求的服务器。这个请求其实是原始请求的镜像，此时其自身相当于一个DNS客户端。 由于这个事务ID与之前捕获文件中的事务ID不同，所以我们可以将这个DNS查询作为一个新的查询。这个数据包被4.2.2.1服务器接收以后，本地DNS服务器就收到了回应，也就是第三个数据包的内容：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/07.jpg)

接收到了这个响应之后，本地DNS服务器就将IP地址传递给了发起DNS请求的客户端。虽然这里只展示了一层递归，但事实上，对于一个DNS请求来说，可能会出现多次递归的情况。在这个例子中，我们是从4.2.2.1服务器中获取IP地址的，但是那个服务器可能为了寻求答案也向其它的服务器执行了递归查询的操作。一个简单的查询在得到最终结果之前，可能会游历全世界。

**DNS区域传送分析**

DNS区域是一个DNS服务器所授权管理的名字空间（或是一组DNS名称）。举个例子来说，ichunqiu这个网站可能由一个DNS服务器对ichunqiu.com负责。这样，不论是ichunqiu内部还是外部的设备，如果希望将ichunqiu.com解析成IP地址，都需要和这个域的DNS服务器联系。现在ichunqiu又多了一个社区功能，那么它可能会增加一个DNS服务器，专门用来处理其名字空间中的`bbs`部分，比如bbs.ichunqiu.com。那么这个服务器，就成为了这个社区子区域的权威。如果有必要的话，还可以为子域名添加更多的DNS服务器，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/08.jpg)

区域传送指的是出于冗余备份的需要，在两台设备之间传送区域数据。比如在拥有多个DNS服务器的组织中，管理员通常都会配置一台备用DNS服务器，用于维护一份主服务器的DNS信息拷贝，以防止主DNS服务器不可用的情况出现。但如果配置不当，就会导致任何匿名用户都可以获取DNS服务器某一域的所有记录，将整个企业的基础业务以及网络架构对外暴露，从而造成严重的信息泄露，甚至导致企业网络被渗透。区域传送主要包含有两种形式：

1、完整区域传送`（AXFR）`

这个类型的传送将整个区域在设备间进行传送。

2、增量区域传送`（IXFR）`

这个类型的传送仅仅传送区域信息的一部分。

实验文件`Lab13-4.pcap`就包含有一个区域传送的例子。首先我们会发现，数据包的类型是TCP而不是UDP。而我们之前也说了，DNS是基于UDP协议的，但事实上，DNS在如同区域传送这样的一些任务中，会使用TCP协议，因为TCP对于规模化的数据传输更为有效。那么很明显，这个捕获文件中的前三个数据包其实就是TCP的三次握手。

接下来的第四个数据包就开始在`172.16.16.164`和`172.16.16.139`之间进行实际的区域传送了。需要注意的是，这个数据包里面并不包含任何DNS信息。而这个数据包被标记为`“TCP segment of a reassembled PUD”`，即“重组PUD的TCP分片”。第五个数据包是对于第四个数据包成功接收的确认。而第六个数据包则可以作为完整的DNS区域传送请求的参考：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51447/09.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51447/09.jpg)

在这里可以看到，区域传送是典型的查询，并且请求的是`AXFR`类型，也就是完整区域传送，意味着它希望从服务器接收全部DNS区域。接下来服务器在第七个数据包中回复了区域记录：

可见，区域传送包含了相当多的数据。如果是复杂的网络情况，还会包含有更多的数据，这就彰显了保证区域传送安全的重要性。在传送完毕之后，捕获文件以TCP的连接终止作为结束。

#### 2.9 HTTP

https://juejin.cn/post/6844903987133546504#heading-16

#### 2.10 HTTPS

**https工作流程**

使用HTTPS协议工作时，服务端和客户端的信息传输都会进行加密，所以传输的数据都是加密后的数据。`HTTPS`的工作流程如下：

![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/01.jpg)

1、客户端使用HTTPS的`URL`访问Web服务器，要求与Web服务器建立SSL连接。

2、Web服务器收到客户端的请求后，会将网站包含有公钥的证书信息传送一份给客户端。

3、客户端浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。



4、客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

5、Web服务器利用自己的私钥解密出会话密钥。

6、Web服务器利用会话密钥加密与客户端之间的通信。

**HTTPS数据包捕获**

由于HTTPS是建立在TCP协议之上的，所以我们在捕获之前，可以设置筛选器为TCP。开始捕获后，可以通过登录QQ邮箱的方式，捕获到含有HTTPS协议的数据包。如下图所示`（Lab15-1.pcapng）`：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/02.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/02.jpg)



在这个界面的Info列中，可以看到这些数据包都是使用HTTPS协议传输的。而在Protocol列中，可以看到`SSL`、`TCP`以及`TLSv1.1`等协议。其中的`TLS（Transport Layer Security）`其实是SSL的升级版，是为网络通信提供安全及数据完整性的一种安全协议。二者都是在传输层对网络连接进行加密的。

为了便于进一步的分析，这里我们依旧可以采用前几次课中说过的，通过着色后提取数据包的方式，将我们需要的数据包提取出来，这里不再赘述。

**HTTPS数据包的分析**

这里我们打开`Lab15-1-https.pcapng`这个实验文件，也就是经过提取后的文件进行分析：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/03.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/03.jpg)



首先可以发现1到3号数据包是TCP连接建立时的三次握手的过程。接下来从第4个数据包开始，其实就是SSL握手过程中所产生的数据包，也就是使用HTTPS协议加密的信息。

对于第4个数据包，包含有客户端向服务器发送的`Client Hello`信息，以便开始一个新的加密会话连接。展开SSL区段，可以看到客户端支持的TLS的版本（`Version`）；生成的随机数（`Random`，以便用于生成对话密钥）；Cipher Suites的值是15，说明支持15种加密算法；支持的压缩方式（`Compression`）以及一些扩展（`Extension`）等：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/04.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/04.jpg)



当服务器收到客户端的请求后，就会向客户端发出响应，也就是`Server Hello`。对于我们这个捕获文件而言，第6个数据包就是服务器发送给客户端的确认信息，告诉客户端请求已经收到：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/05.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/05.jpg)



展开SSL数据段，可以看到服务器支持的TLS版本为1.1。也可以看到服务器生成的随机数，用于生成对话密钥。下面还有加密套件信息，这里的加密套件表示使用RSA公钥算法来验证证书以及交换密钥，用AES加密算法对数据进行加密，使用SHA算法来校验消息内容。

客户端收到服务器的响应后，首先验证服务器的证书。如果证书不是由可信任的机构颁发的，或者证书中的域名与实际域名不一致，或者证书已过期，就会向访问者显示一个警告，由访问者选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送一些信息，包括用服务器公钥加密的随机数、编码改变通知和客户端握手结束通知等。服务器发送给客户端的数据包，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/06.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/06.jpg)



在Certificate区段中，保存有证书的详细信息。可以看到请求的网站、组织名、地区名、省名以及国家等的信息。紧接下来的signedCertificate是签名证书信息。“签名”的作用就在于，客户端（浏览器）在确定是否要信任一个网站时，就是通过证书判断的。所以每个证书上必须要有一份“签名”。最后一行Length的值为0，表示告诉客户端“Hello”过程已经完成，也就意味着服务器将不验证客户端的证书。

在客户端收到并验证服务器响应的证书后，将会把生成的密钥传给服务器，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/07.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/07.jpg)



在Client Key Exchange中，我们可以看到TLS的类型、版本、长度、握手协议、握手类型、长度、密钥交换算法客户端参数、公钥长度以及加密公钥等信息。而在其它的两个记录中，也有着类似的结构。

经过以上几个阶段，整个握手过程也就结束了。接下来客户端与服务器进入加密通信的阶段，就完全是使用普通的HTTP协议，但是会使用会话密钥来加密内容。用户可以发送通过TLS层使用RC4加密的HTTP的消息，也可以解密服务端发送来的由RC4加密的消息。此外还会通过哈希算法来验证消息是否被篡改。

在应用层，客户端向服务器发送的信息为：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/08.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/08.jpg)



可见，发送的数据都经过了加密处理。服务器响应客户端的信息，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/09.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/09.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/09.jpg)



可以看到，这也是使用了`SSL`进行加密。

**了解HTTPS数据包的解密**

HTTPS的数据包并不是绝对安全的，在一定的条件下也可以实现解密的操作，这里我们打开Lab15-2.cap实验文件：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/10.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/10.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/10.jpg)



可以看到，这里的数据包使用了SSLv3进行加密。为了实现解密，我们需要Lab15-2.key文件。为了便于寻找，这里我将这个文件放在了我的电脑中的C盘根目录下。之后在Wireshark中选择菜单栏的`“Edit”->”Preferences”->”Protocols”->”SSL”->”RSA keys list”->”Edit”->”New”`，之后进行如下填写：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/11.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/11.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/11.jpg)



之后点击OK，就可以实现解码了：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/12.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51451/12.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51451/12.jpg)



现在已经可以看到GET方法等信息。尽管我们对捕获文件进行了解码操作，但是并不意味着HTTPS不安全。因为解码所需要使用的密钥只能在服务器导出，不同的服务器的情况并不一样，因此想要破解HTTPS的数据包，是需要满足很多的条件的。

#### 2.11 协议中的活化石-FTP

步骤1：下载实验文件

请访问`http://file.ichunqiu.com/024f959c`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

步骤2：FTP的工作流程

FTP的工作流程如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/01.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/01.jpg)



图中的客户端是希望从服务器端下载或上传文件的计算机。服务器端是提供FTP服务的计算机，它监听某一端口的TCP连接请求。而FTP服务一般运行在20和21两个端口。其中的端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流，是FTP命令通向FTP服务器的入口。控制连接和数据连接都是TCP连接，控制连接用于传送用户名、密码及设置传输方式等控制信息，数据连接用于传输文件数据。客户端和服务器端分别运行着控制进程和数据传送进程。



当用户需要从服务器下载文件时，可以通过客户界面让客户端的控制进程发起一个TCP连接请求。服务器端的控制进程接受了该请求之后，建立了控制连接。于是，双方就可以相互传递控制信息了，但此时双方还不能传输文件数据。为了传输数据，双方的数据传送进程还需要再建立一个数据连接。

当客户端向服务器端发出建立TCP控制连接请求时，使用的服务器端的默认端口号是21，同时要告诉服务器端一个空闲的端口号，用于以后建立数据传输连接。然后，服务器端使用默认的20号端口与客户端所提供的端口建立数据传送连接，然后开始数据的传输。

一般情况下，控制连接是一直存在的，但数据连接在一个文件传输完毕之后就会断开。如果还需要传输另一个文件，则需要重新建立数据连接。这个特性使得FTP在传输大量的小文件时效率比较低，因为每一个文件传输时都需要建立和关闭TCP连接。这样会消耗一定的时间。

FTP的工作模式和其它网络通信协议有很大的区别。通常在使用HTTP等协议进行通信时，通信双方只用一个通信端口进行通信，即只有一个连接。而FTP使用两个独立的连接，其主要优点是使网络数据传输分工更加明确，同时在文件传输的时候还可以利用控制连接传送控制信息。

步骤3：FTP数据包分析

了解了关于FTP的基础知识，那么下面我们就可以尝试分析FTP的数据包了，看看基于FTP协议的数据包在Wireshark中的表现。实验文件`Lab16-1.cap`记录了一次利用Windows客户端登录FTP服务器，并且下载了一个文件的过程：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/02.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/02.jpg)



这个捕获文件中的前三个数据包是由客户端发起的TCP的三次握手，并且在第2个数据包中我们也可以发现，FTP服务器的控制端口21。

接下来我们详细分析一下FTP的数据包，也就是5、7、8、10以及11号数据包。可以点击一下`Protocol`列，使其以协议名称进行排序：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/03.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/03.jpg)



可以看到其中的5号数据包是服务器端发往客户端的，说明服务器端已经做好了准备，并包含了自己的一些信息。7号数据包是由客户端发出的，请求以一个用户名进行登录。8号数据包是对7号的回应，服务端要求客户端提供与登录用户名相对应的登录密码。于是客户端在第10号数据包中，将密码发送给了服务器端。经过服务器的验证，用户名和密码没有问题后，利用第11号数据包回复客户端登陆成功。

由上述的一系列分析可见，FTP是使用明文进行传输的，用户名和密码都可以在Wireshark中看到，如果对于安全的要求非常高，那么就不可以采用这样的方式。

接下来分析一下下载过程的数据包。第13号数据包是客户端发送的请求，说明客户端想从IP地址为`10.32.200.41`，端口号为`208*256+185=53433`连接对方的数据端口，注意这里的256是约定好的常数。那么接下来的14号数据包则是对此的回应，说明服务器已经同意了请求。接下来的15号数据包，客户端要求服务器传输文件，而22号数据包则回应文件已经传送了。

但是这些FTP数据包并没有真正实现文件的传送。所以这里我们可以关注一下16到24号数据包的情况：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/04.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/04.jpg)



可以看到，在客户端要求服务器端传送文件之后，从第16号数据包开始，是TCP的三次握手，不过这次是FTP服务器发起的握手，服务器的端口号是20，正是数据传输端口，而客户端的端口号就是之前协商得到的53433号端口。接下来的19号数据包，所传送的就是文件的内容。当然这里所传输的是一个非常简单的文件，如果捕获到了一个较为复杂的文件，我们通过分析其二进制码的特征，就可以知道该文件的类型了。然后将该二进制码读取出来，并以相应的后缀名保存，就可以打开了。之后的20、21、23、24号数据包，则是TCP连接结束的四次握手的过程，表示数据传输结束，TCP连接也就关闭了。

步骤4：配置了防火请的FTP数据包分析

我们刚才所分析的是正常情况下，FTP数据包的情况。但是现实中，出于网络安全的考虑，我们可能会为FTP配置防火墙。但是这种方式会带来一个严重的问题，由于数据传输连接的三次TCP握手是由服务器主动发起的，也就是主动模式，那么如果客户端的防火墙阻挡了连接请求，那么很可能导致传输的失败。所以在这种情况下，我们应当使用FTP的被动模式。被动模式可以在所使用的FTP客户端进行设置。实验文件`Lab16-2.cap`是在FTP的被动模式下获取的文件：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/05.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/05.jpg)



这里我们同样先分析一下FTP数据包。由于被动模式和主动模式的登陆过程是完全一样的，因此这里只着重分析登陆后的情况，也就是从第24号数据包开始。这个数据包中，客户端要求以被动方式传输数据。接下来服务器回应说，可以连接到IP地址为`10.32.106.112`，端口号为`240*256+217=61657`。注意如果是主动模式，IP地址以及端口号是由客户端发给服务器的。之后的第29号数据包，客户端提出了文件下载的请求，之后服务器通过30号数据包说明文件即将传输。接下来看一下26到35号数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/06.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/06.jpg)



26、27和28号数据包是TCP连接的三次握手，这个连接由客户端主动发起，那么相对于服务器来说就是被动的。连接的服务器端口是之前商定好的61657。之后的31号数据包完成了数据的传输，从32号开始的四个数据包则是TCP断开的四次握手。接着看一下39至44号的数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/07.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/07.jpg)



当我们想退出的时候，可以在FTP的命令行中输入bye，那么在Wireshark中的显示就是，第39号数据包，也即是客户端要求退出，之后服务端很有礼貌地回应Goodbye。然后再通过TCP的四次握手断开控制连接，就完成了一次FTP的活动周期。

步骤5：查看Windows上的小bug

理论上，所有的FTP客户端都应当支持主动和被动两种模式，但是Windows自带的FTP命令却只支持主动模式。为什么这么说呢，比如我们在Windows的FTP命令行中首先利用quote pasv进入被动模式，之后进行数据传输，来分析一下此时获取的数据包（Lab16-3.cap）：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51457/08.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51457/08.jpg)



可以看到，12号数据包说明客户端要求进入被动模式，而13号数据包中，服务端也同意了客户端的请求，并且给出了IP地址以及端口号。那么按理说就应当进入被动模式了，但是接下来数据包的传输方式却依旧按照主动传输进行的。因为接下来的第15号数据包，客户端又给出了一个IP地址以及端口，而接下来的数据传输就是依据这个端口和IP地址进行的。包括TCP的三次握手也是由服务器主动发起的。也就是说，在Windows自带的FTP中，尽管选择了被动模式，但是数据的传输方式却是依照主动模式的，那么可以认为Windows自带的FTP只有主动模式。因此可以认为这是Windows系统上的一个bug。

#### 2.12 固若金汤的Kerberos

实验步骤

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/eb9ed793`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：Kerberos的实现原理**

那么这个`Kerberos`是什么意思呢？相信看过希腊神话或者《圣斗士-冥王篇》的朋友应该都知道，在渡过了冥河之后，冥界的大门由一只巨大的三头猎犬所看守，保证冥界的大门只许进不许出，令冥界之门固若金汤。而这只猎犬的名字就是Kerberos，应用于我们所讲的网络认证中，表示这是安全的象征。

在实际的网络应用中，Kerberos的认证结果是双向的，也就是当帐号A访问资源B的时候，不但B要确保A并非冒充，而且A也要查明B的真实身份。而双向认证的方式并不止一种，最简单的方式就是互报接头暗号。如果大家看过《林海雪原》，就会知道当时杨子荣深入虎穴，在面对土匪时，土匪说“天王盖地虎”，杨子荣回复到”宝塔镇河妖” ……那么其实这就是密码技术在现实中的应用，也正是因为杨子荣对上了暗号，才会让土匪相信了他是自己人。但是这种方式的弊端有很多，最大的问题是管理起来不方便。比如在一个数百名员工共享几百台机器的环境中，当加入一名新员工时，就需要在几百台的机器上更新帐号信息。那么这对于网络管理员来说是无法容忍的。



为了解决这个问题，Kerberos引入了一个权威的第三方来专门负责身份的认证工作。这个第三方就称之为KDC，他知道所有的账号和密码。这样一来，假如账号A想要访问资源B，那么利用`KDC`就可以验证双方的身份了。因此，A和B都不需要知道对方的密码，可以完全依赖于KDC。

Kerberos的原理说起来简单，但是通过程序来实现还是比较困难的。包括想要彻底理解它的验证流程，如果仅仅通过文字说明，学起来还是有难度的。但是如果利用Wireshark进行分析，就可以使得Kerberos的验证流程变得清晰很多。整个验证流程可以分为三大步骤，下面我们结合实验文件`Lab17-1.pcap`逐一进行分析。

**第一步，账号A和KDC互相认证。**

1、账号A利用哈希函数将密码转化成一把密钥，这里称它为`Key-Client`。

2、利用Key-Client将当前的时间戳加密，生成一个字符串。表示为`“{时间戳} Key-Client”`。

3、将上一步生成的字符串“{时间戳} Key-Client”、账号A的信息以及一段随机字符串发给KDC。这样就组成了Kerberos的身份认证请求AS-REQ，可以使用下面的公式来表示：

AS-REQ=“{时间戳} Key-Client”+“账号A的信息”+“随机字符串”。

如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/01.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/01.jpg)



这里需要注意的是，当前捕获文件中的数据是处于加密状态的，这不利于我们的分析。不过只要知道密码，就可以生成解密文件，这里也给大家提供了名为Lab17-1.keytab的解密文件，我们可以在菜单栏中选择`“Edit”->”Preferences”->”Protocols”->”KRB5”`，之后勾选两个选项，并输入解密文件的名称，之后就可以看到解密后的内容了。但是这个功能只能够支持32位的Wireshark，64位的还不支持。并且解密文件的路径最好不要有中文，放在C盘根目录下即可。之后再次查看第一个数据包的内容：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/02.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/02.jpg)



上图中的KerberosString后面的内容就是账号A的信息，而nonce后面的内容就是随机字符串。

4、KDC收到AS-REQ之后，读取到A的信息，就可以调出A的密码，再使用同样的哈希函数将其转化为Key-Client。有了Key-Client就可以解开“{时间戳} Key-Client”了。如果能够成功解开，就说明这个请求是由账号A生成的，毕竟其它账号不可能有Key-Client进行加密。

Kerberos之所以使用时间戳进行加密，原因就在于如果黑客在网络上截获了字符串“{时间戳} Key-Client”，那么就有可能伪装成账户A来欺骗认证。这种方式就称为重放攻击。采用这种攻击方式需要一定的时间，所以KDC把解密得到的时间戳和当前的时间作对比，如果二者的差异过大，那么就可以认为遭受到了重放攻击。假如采用与时间无关的字符进行加密，那么是无法避开重放攻击的，因此这就要求域中的所有计算机要在时间上同步。其实这种计算前后时间差的思想往往也会应用于反调试技术中，有兴趣的朋友可以关注`《恶意代码分析实战》`系列的课程。

5、接下来，KDC需要向账号A证明自己的身份，刚才提到的随机字符串就需要用在这里。理论上KDC只要使用Key-Client加密随机字符串，再回复给账号A就可以证明自己的身份了。因为假的KDC是没有Key-Client的，那么账户A收到假的KDC的回复后，解不开那个随机字符串，就知道KDC是假的。

总结上面的流程，账号A和KDC都没有向对方发送密码，所以即便有一方是假的也不会导致信息的泄露。如果双方都是真的，则可以实现相互认证的过程。但是这个机制中的KDC是非常忙碌的，因为每次的认证都需要调出密码账号、进行哈希运算、实现解密操作……每个客户端一天可能会验证数十次，那么域中就需要配置大量的KDC才能够负担得起，因此改进流程就显得很有必要了。Kerberos在这里设计了一个比较巧妙的方法：

a.KDC生成两把一模一样的密钥`Key-Client-KDC`，用于以后账户A和KDC之间相互的认证，这样就省去了调出账号A的密码和哈希等的工作。按理说其中的一把Key-Client-KDC应当由账户A保管，另一把由KDC自己保管。但是KDC本来就很忙碌，额外再保管密钥会加重自身的负担，因此这个密钥就委托给账户A来保管，那么以后账户A需要KDC的时候，再把这个密钥还回来就可以了。但是这里面有一个问题，那就是如果有个假冒的账户A交回来一个假的密钥怎么办？为了避免这个问题，KDC把自己的密码哈希成Key-KDC，然后用它加密那把委托给账户A的密钥。Kerberos将这个密钥称为`TGT（Ticket Granting Ticket）`，可以用以下公式表示：

TGT={账户A的相关信息，Key-Client-KDC} Key-KDC

有了这个委托保管的机制，那么KDC只需要记住自己的Key-KDC，就可以解开委托给所有账号的TGT，从而获得与该帐号之间的密钥。通过这个机制，KDC的工作负担就大大降低了。那么总结以上可以知道，KDC回复给账户A的AS-REP应当包括以下信息：

AS-REP=TGT，{ Key-Client-KDC，时间戳，随机字符串} Key-Client

那么相对应的，就是捕获文件中2号数据包的内容：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/03.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/03.jpg)



这其中的ticket就是TGT，下面的key表示的是Key-Client-KDC，Lr-time是时间戳，nonce是随机字符串，它与第一个数据包中的字符串是一致的。

b. 账户A收到AS-REP之后，利用Key-Client解密“{ Key-Client-KDC，时间戳，随机字符串} Key-Client”，通过解密得到的随机字符串和时间戳来确定KDC的真实性，然后把Key-Client-KDC和TGT保存起来备用。

**第二步，账号A请KDC帮忙认证资源B。**

1、现在应当把TGT交还给KDC，其次还有账户A的相关信息、当前时间戳以及要访问的资源B的信息。这个请求在Kerberos中被称为`TGS-REQ`，可以使用以下公式表示：

TGS-REQ=TGT，{账户A的相关信息，时间戳} Key-Client-KDC，“资源B的相关信息”

如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/04.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/04.jpg)



图中的ticket是要交还给KDC的TGT，下面的KerberosString表示A的帐号信息，ctime是时间戳，最后的两个KerberosString表示资源B的信息。

2、KDC收到TGS-REQ之后，先使用Key-KDC解密TGT得到Key-Client-KDC，再使用Key-Client-KDC解密出账号A的相关信息和时间戳来验证其身份。一旦认定账号A为真，那么接下来就要帮助A和B进行相互认证了。

3、KDC生成两把同样的密钥供A和B之间使用，我们就称这个密钥为Key-Client-Server。其中一把密钥直接交给账号A，另一把委托A转交给资源B。为了确保A不会受到假的资源B所骗，Kerberos把B的密码哈希成Key-Server，然后用它加密那把委托A转交给B的Key-Client-Server，成为一个只有真正的B才能够解密的ticket。总结以上，KDC给账号A的回复可以表示为：

Ticket={账号A的信息，Key-Client-Server} Key-Server

TGS-REP={ Key-Client-Server} Key-Client-KDC，ticket

这里的“账号A的信息”不单单包括A的名称，还包括A所在的域组（Domain Groups）。因此如果A属于很多个组（Groups），那么TGS-REP数据包就会很大。如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/05.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/05.jpg)



上图中的ticket就是“{账号A的信息，Key-Client-Server} Key-Server”，cipher后面的内容就是“{ Key-Client-Server} Key-Client-KDC”，下面的keyvalue的值就是Key-Client-Server。

4、账号A收到TGS-REP之后，首先使用Key-Client-KDC解开{ Key-Client-Server} Key-Client-KDC，从而得到Key-Client-Server。Ticket留下来发给资源B。接下来如果需要多次访问资源B，都可以使用同一个ticket，而不需要每次都向KDC申请，这就降低了KDC的负担。

**第三步，账号A和资源B互相认证。**

1、这时候，账号A给资源B发送“{账号A的信息，时间戳} Key-Client-Server”以及之前收到的ticket，这个请求称为AP-REQ：

AP-REQ=“{账号A的信息，时间戳} Key-Client-Server”，ticket

如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/06.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/06.jpg)



2、如果资源B是假的，那么它就解不开ticket。如果资源B是真的，它可以用自己的密码生成Key-Server来解开ticket，从而得到`Key-Client-Server`。有了Key-Client-Server就可以解开“{账号A的信息，时间戳} Key-Client-Server”部分。这样资源B就可以确定账号A为真，然后回复AP-REP来证明自己也是真的：

AP-REP={时间戳} Key-Client-Server

3、账号A利用Key-Client-Server来解密`AP-REP`，再通过得到的时间戳来判断对方是否为真。如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51459/07.jpg)

[Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51459/07.jpg)

#### 2.13 Linux中的NFS协议

**实验环境**

- 操作机：`Windows XP`

**实验目的**

学习Linux中的NFS协议解析，注意理解和区别

**实验工具**

- `wireshark`：Beyond Compare是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换，是目前全世界最广泛的网络封包分析软件

实验文件：

- `Lab18-1.pcap`
- `Lab18-2.pcap`
- `Lab18-3.pcap`
- `Lab18-4.cap`

**实验内容**

**实验步骤**

**NFS就是Network File System的缩写，它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。**

 **NFS服务器可以让PC将网络中的NFS服务器共享的目录挂载到本地端的文件系统中，而在本地端的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样，在使用上相当便利；**

**NFS一般用来存储共享视频，图片等静态数据。**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/686f863d`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：学习NFS协议的挂载**

这里我们结合着`Wireshark`来分析一下NFS协议数据，来学习一下它的挂载过程、安全机制以及读写过程，以直观的方式进行学习。首先分析一下协议的挂载，实验文件`Lab18-1.pcap`就是在执行挂载命令`（mount）`时所捕获的数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51463/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51463/01.jpg)

上图中，IP地址为`10.32.106.159`是客户端，`10.32.106.62`则为服务器端，我们逐条分析一下每个数据包：

1：客户端想连接服务器的NFS进程，于是询问应该使用哪个端口（GETPORT）。在这里我们可以看到“Reply In 2”，说明2号数据包就是对于这个数据包的回应。

2：服务器回应说，NFS端口是2049。那么这里的“Call In 1”说明本数据包是对于1号数据包询问的回应。

3：客户端尝试连接服务器的NFS进程。并且还可以判断2049端口是否被防火墙拦截，以及NFS服务是否已经启动。

4：服务器回应，收到请求，可以连接上。

5：客户端想连接服务器的挂载（mount）服务，询问该服务的端口。由于mount服务的端口号是比较随机的，因此客户端必须要进行询问。

6：服务器回应自己的mount服务端口为1234。

7：客户端尝试连接mount进程。同理，也可以判断1234号端口是否被防火墙所拦截，还有mount进程是否已经成功启动。

8：服务器回应收到请求，可以连接。

9：客户端提出要求，请求挂载`（MNT）“/code”`这个共享目录。NFS主要提供了/code以及/document两个共享目录，分别被挂载到多台客户端的本地目录上。当用户在这些本地目录进行文件的读写时，实际上是在NFS的服务器上进行的。

10：服务器同意了客户端的请求。通过查看Packet Details面板可以知道，服务器要求客户端使用`file handle 0x75a18429`进行目录的访问。

11：客户端尝试客户端的NFS进程是否能连接上。

12：服务器回应可以连接。其实这两步完全没有必要，因为NFS一直处于连接的状态。这个问题估计和我们之前讨论的Windows中FTP的主动和被动模式一样，是开发人员的疏忽造成的。如果他们当时能够熟练使用Wireshark进行测试，相信不会出现这样的问题。

13：客户端要求查看文件句柄为`0x75a18429`的文件的属性。

14：服务器为客户端提供了该文件系统的大小和空间使用率等属性，之后就可以在客户端看到这些信息了。

15：客户端要求查看文件句柄为`0x75a18429`的文件的属性。

16：服务器为客户端提供该文件的属性。那么很明显，这两步也是多余的操作，估计原因同上。

这里需要说明的是，为了便于大家的理解与观察，这个捕获文件中只保留了关键步骤，而删去了关系不太大的数据包。大家如果分析真实的场景，所捕获到的数据包会比这复杂很多，但是原理是一致的。

利用Wireshark就可以很清晰地看到，如果portmap请求没有得到回复，这就说明很可能是防火墙对相关端口进行了拦截；如果发现mount请求被服务器拒绝了，那么可以考虑检查一下共享目录的访问设置。

**步骤3：了解NFS的安全机制**

NFS的安全机制主要包括对客户端的访问控制以及对用户的权限控制。NFS对客户端的访问控制是通过IP地址实现的。创建关键共享目录时可以指定哪些IP允许读写，哪些IP只允许读操作，还有哪些IP不给予任何权限。这方面的配置虽然并不复杂，但是一旦出现问题，却难以排查，当然如果借助于Wireshark，问题往往能够很快迎刃而解。

NFS的用户权限往往会使人困惑。有这样一个例子，一个客户端上的用户admin在/code目录里面新建了一个名为abc.txt的文件，该文件的owner正常显示为admin。但是在另一台客户端上查看该文件时，owner却变成了nasadmin。那么这里我们可以借助于Wireshark来分析一下实验文件Lab18-2.pcap，它展示了用户admin在创建abc.txt时的数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51463/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51463/02.jpg)

我们关注一下第4个数据包。从上图中的Credentials中可以看到，用户在创建文件时并没有使用admin这个用户名，而是使用了admin的UID 501来代表自己的身份。而NFS协议是只认UID不认用户名的。当admin通过客户端创建了一个文件，那么UID 501就会被写到文件里面，成为了owner的信息。而当另一个客户端上的用户查看该文件的属性时，看到的就是UID 501。但是不同的客户端上UID值与其所对应的名称往往是不一致的。因此创建文件的客户端的UID 501表示的就是admin，但是换了客户端，UID就对应着nasadmin了。那么为了防止这样的问题，需要大家在实际的操作中，保证每个客户端的UID与用户名的映射是一致的。

**步骤4：了解NFS的读文件过程**

这里我们研究一下NFS协议读取文件`abc.txt`的过程，结合实验文件`Lab18-3.pcap`进行分析：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51463/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51463/03.jpg)

由于捕获文件中包含有很多关于数据传输的数据包，而那些数据包并不是我们关注的重点，所以我们可以利用筛选器，只保留NFS数据包。我们逐条分析一下每个数据包：

1：客户端向服务器询问，是否可以进入`（ACCESS）FH`为`0x75a18429`，也就是/code里面。

2：服务器回应说允许进入。

3：客户端想要查看这个目录里面的文件和文件的句柄。

4：服务器回应了客户端索要的信息，此时可以展开Packet Details来查看文件信息：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51463/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51463/04.jpg)

可见abc.txt的file handle为`0x056560e1`。

5：客户端询问file handle为`0x056560e1`的文件属性是什么。

6：服务器回应了该文件的权限、UID、GID以及文件的大小等信息。

7：客户端询问是否可以打开file handle为`0x056560e1`的文件。

8：服务器同意了请求，并给予了相应的权限。

9：从`0x056560e1`的偏移量为0的位置，也就是`abc.txt`文件的开头位置，读取（READ）131072字节的数据。

10：从`0x056560e1`的偏移量为`131072`的位置，再读取131072字节的数据。

148：服务器回应客户端，允许读取131072字节的数据。

288：同上。

这样，NFS就完成了文件的读操作。

**步骤5：了解NFS的写文件操作**

这里我们通过实验文件`Lab18-4.cap`来分析一下，将名为abc.txt的文件写入NFS共享文件夹的过程。首先依旧加入筛选条件nfs：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51463/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51463/05.jpg)

1：客户端向服务器发出请求，要求进入`0x75a18429`，也就是/code目录。

2：服务器接受请求。

4：客户端询问服务器，查找（LOOKUP）名为abc.txt的文件。因为在创建一个文件之前，需要首先检查一下是否有同名文件的存在。如果不存在同名文件，才能够继续写入，否则要询问用户是否覆盖原文件。

5：服务器回应没有这个文件。

6：客户端要求创建（CREATE）一个名为abc.txt的文件。

7：服务器答应了请求。此时在Packet Details面板中展开NFS区段，就可以找到文件的file handle为`0x056560e1`。

69：客户端要求从`0x056560e1`的偏移为0的位置，也就是abc.txt文件的开头，写入（WRITE）131072个字节。

104：服务器回应已经写完了。

130：客户端要求从`0x056560e1`的偏移为131072的位置，也就是abc.txt文件的开头，写入（WRITE）131072个字节。那么接下来的两个数据包也是这个道理。

302：服务器回复已经写入。下面两个数据包同理。

306：客户端询问，刚才所写的数据是否已经存盘，也就是COMMIT操作，只有经过COMMIT过的数据才算是真正的写好了。

307：服务器回应都保存好了。

308：客户端要求查看刚才所写入的文件的属性（GETATTR）。

309：服务器将文件的权限、UID、GID以及文件的大小等信息交给客户端。

由这个例子可以发现，写操作是多个WRITE Call连续发送过去的。其实我们刚才的读文件的操作也是如此。同时将多个请求一起发出，接下来等待回应的这种方法，比发一条回复一条，发一条回复一条的方式要更加有效率。特别是在高带宽高延迟的情况下，NFS的这种读写特性的优势就会非常的明显。对于写操作而言，如果我们在挂载的时候没有指定任何参数，那么就会采用默认的async（异步）写的方式。而与之相对应的是sync（同步）方式。如果在挂载时指定了sync参数，那么客户端就会先发送一个WRITE Call，等到收到Reply之后再发送下一个请求，也就是说，请求和回应是交替出现的。对于我们这个捕获文件而言，由于采用的是默认挂载方式，所以数据包的WRITE操作会有一个UNSTABLE，表示的是异步的方式。如果是同步方式，则会出现FILE_SYNC的标志。

所以，假设我们在实际的网络中，NFS的读写性能有问题，那么可以通过抓包看一看，是不是开启了同步的模式，或者有其它多余的操作。

#### 2.14 windows中的文件共享协议

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/bd71154a`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：CIFS协议分析**

这里我们借助于实验文件`Lab19-1.cap`进行分析：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/01.jpg)

首先，由于CIFS是基于TCP的，所以由TCP的三次握手作为开始。并且可以发现，CIFS的端口号是`445`。从第4个数据包开始，就是CIFS协议了。但是这里显示的是SMB，其实CIFS协议有三个版本：SMB、SMB2和SMB3，目前SMB以及SMB2用得比较普遍。接下来可以看到第4个数据包是一个`Negotiate`（协商）。关于其协商的内容，我们可以展开Packet Details面板中的SMB来查看。可以发现客户端将自己支持的CIFS的版本，比如NT LM 0.12以及SMB 2.002等都发给了服务器。接下来有：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/02.jpg)

服务器对此的回应位于第6个数据包。它从客户端发出的数据包中挑出自己所支持的最高版本，回复给客户端。可见服务器选择的是NT LM 0.12。

在协商好版本之后，就可以建立`CIFS Session`了，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/03.jpg)

Session Setup的主要任务是进行身份的验证，常用的方式有Kerberos和NTLM，而本例中所使用的就是后者。假如我们在实际的应用中，发现有访问不了CIFS服务器的情况，那么问题很可能就是发生在Session Setup的地方。

在Session Setup完成之后，这就意味着已经打开`\\10.32.106.72`了，那么接下来要做的就是打开\dest共享。那么这个操作在Wireshark中就显示为Tree Connect。可以查看一下12号数据包，展开SMB Header区段，其中最有价值的信息就是服务器返回的Tree ID的值。因为客户端需要使用这个ID去访问/dest共享的子目录和子文件。

这里需要注意的是，Tree Connect这一步并不会检查权限，所以即便是无权访问的用户也可以得到Tree ID。因为检查权限的工作是由接下来的Create操作完成的。

接下来的13到68号数据包查询了文件的基本属性、标准属性、扩展属性以及文件系统的信息等。第69号数据包是Create Request \a.txt。Create是CIFS中的一个非常重要的操作。无论是文件的新建、目录的打开，还是文件的读写，都需要使用Create。在这里如果我们没有权限，就会遇到“Access Denied”错误，或者在覆盖文件时也会收到“File Already Exists”的提醒，这些都是来源于Create这个操作。

这里有个问题，CIFS如何保证缓存数据的一致性呢？其实客户端可以暂时把文件缓存在本地，等用完之后再同步回服务器端。当只有一个用户在访问某个文件的时候，在客户端缓存该文件是安全的，但是在有多个用户访问同一个文件的情况下，就有可能出现问题。因此，CIFS采用了Oplock（机会锁）来解决这个矛盾。Oplock有Exclusive、Batch和Level2三种形式。Exclusive允许读写内存，Batch允许缓存的所有操作，而Level2只允许读缓存。Oplock也是在Create中实现的，比如看一下第70号数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/04.jpg)

可以看到，该客户端被授予Batch级别的机会锁，表示它可以缓存所有操作。至此，已经经过了70个数据包，而我们的文件读取的操作却还没有开始，可见CIFS协议的过程是多么的啰嗦。其实由此我们可以解释一个很经典的问题，那就是“为什么复制一个1MB文件的时间要比复制1024个1KB文件的时间快得多，尽管二者的大小是一样的”，原因就在于对文件进行读写时，需要花费大量的时间和步骤在这类琐碎的事情上。一个1MB的文件只需要准备一次，但是1024个1KB的文件却要进行1024次的前期工作。

从第71号数据包开始，就开始了读操作。其实微软所设计的CIFS的读文件行为和Linux上的NFS协议的原理很相像，都是从某个偏移（offset）开始读取一定数量的字节。71号数据包是请求从文件`a.txt`的偏移为0的位置读取18个字节的内容，而72号数据包就是对此的回应：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/05.jpg)

可以看到文件的内容并没有加密，在Wireshark中可以直接看到。

**步骤3：CIFS协议的对比分析**

接下来我们做一下对比，看看CIFS协议在Windows XP以及Windows 7系统中有什么不一样的地方。首先可以研究一下读文件的模式。在Windows XP中，在发送了一个读请求之后，会停下来等待回复，只有在收到回复之后，才会继续发送下一个读请求。但是Windows 7却可以一口气发送多个请求。这就类似于我们上次课所讲解的NFS的同步和异步的模式。实验文件Lab19-2.cap展示了在Windows XP中的情况：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/06.jpg)

实验文件Lab19-3.cap则展示了Windows 7的情况：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51481/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51481/07.jpg)

事实上，这两种方式在延迟小的网络中体现不出差别，在带宽小的环境中差别也不大。但是在高延迟、大带宽的环境中就会很不一样了，Windows 7的性能会比Windows XP好很多。在网络有丢包的情况下差别还会更大，因为Windows XP比Windows 7更容易遇到超时重传的情况。

#### 2.15 E-Mail数据包的分析

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/c5850661`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：电子邮件的传输机制**

电子邮件系统是基于客户端/服务器模式的`（C/S）`，但是邮件从发件人的客户端发送到收件人的客户端的过程中，还需要邮件服务器之间的相互传输。因此，与其它单纯的客户端/服务器的工作模式（如FTP、Web等）相比，电子邮件系统相对要复杂。其示意图如下：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/01.jpg)

从上图中可以看到，整个电子邮件的传输过程是由多个软件程序组成的。包括有：

1、`MUA（Mail User Agent，邮件用户代理）`：一般也被称为邮件客户端软件。MUA软件的功能是为用户提供发送、接收和管理电子邮件的界面。比如我们这次的实验所使用的`Foxmail`就属于`MUA`。

2、`MTA（Mail Transfer Agent，邮件传输代理）`：一般也被称为邮件服务器端软件。MTA软件负责接收客户端软件发送的邮件，并将邮件传输给其它的MTA程序，是电子邮件系统中的核心部分。

3、`MDA（Mail Delivery Agent，邮件分发代理）`：MDA软件负责在服务器中将邮件分发到用户邮箱目录。MDA软件比较特殊，它并不直接面向邮件用户，而是在后台默默地工作。有时候MDA的功能可以直接集成在MTA软件中，因此常常被忽略。

上图所示的详细过程如下：

1、MUA使用`SMTP`协议将邮件发送给`MTA`。

2、MTA收到邮件后，要根据收件人的信息决定下一步的动作。如果收件人是自己系统上的用户，则直接投递。反之则需要把邮件传递给对方网络系统的MTA。此时可能需要经过多个MTA的转发才会真正到达目的地。如果邮件无法投递给本地用户，也无法转交给其它的MTA处理，则需要把邮件退还给发件人，或者发通知邮件给管理员。

3、邮件最终到达了收件人所在网络的MTA，于是该MTA发现收件人是本地系统的用户，就交给了MDA处理，MDA再把邮件投递到收件人的信箱里。信箱的形式可以是普通的目录，也可以是专用的数据库。不论是哪种形式，这些邮件都需要有一种长期保存的机制。

4、邮件被放入信箱后，就会一直保存下来，直到收件人来取。收件人也是通过MUA来读取邮件的，但是此时MUA要联系的并不是发邮件时所联系的MTA，而是另一个提供`POP/IMAP`服务的软件。而且读取邮件时所采用的协议也不是SMTP，而是POP3或者IMAP。

上图中的两个MTA分别承担了发邮件和收邮件的功能。实际上，任何MTA都可以同时承担收邮件和发邮件的功能。也就是除了接受MUA的委托，将邮件投递到收件人所在的邮件系统以外，还可以接收另一个MTA发来的邮件，然后根据收件人信息决定投递给本地用户还是转发给其它的MTA。

**步骤3：SMTP协议概述**

`SMTP（Simple Mail Transfer Protocol）`即简单邮件传输协议，它是一种用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，使用的默认端口号为25。它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器，就可以把E-mail寄到收信人的服务器上了。SMTP服务器是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。它使用由TCP提供的可靠的数据传输服务把邮件消息从发信人的邮件服务器传送到收信人的邮件服务器。跟大多数应用层协议一样，SMTP也存在两个端：在发信人的邮件服务器上执行的客户端和在收信人的邮件服务器上执行的服务器端。SMTP的客户端和服务器端同时运行在每个邮件服务器上。当一个邮件服务器在向其他邮件服务器发送邮件消息时，它是作为SMTP客户在运行。SMTP的工作模型如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/02.jpg)

1、发送方首先向对方的25号端口发起TCP的连接请求，接收方收到请求之后，就建立了TCP连接。

2、连接建立之后，发送方就可以向接收方发送SMTP命令了。

3、接收方收到命令之后，根据具体的情况决定是否执行，然后给发送方返回相应的应答。

**步骤4：POP协议概述**

`POP（Post Office Protocol，邮局协议）`主要用于从邮件服务器收取邮件。目前POP协议的最新版本为POP3。大多数的MUA软件都支持使用POP协议，因此应用得最为广泛。POP3协议使用的TCP端口为110。其工作模型与SMTP类似，主要分为以下几个步骤：

1、客户端首先向POP3服务器的110号端口发起TCP连接请求，服务器接受了请求之后就建立了TCP连接。

2、建立连接之后，客户端就可以向服务器发送POP3命令了。

3、服务器收到命令之后，根据具体的情况决定是否执行，然后给客户端回复相应的应答。

**步骤5：IMAP协议概述**

`IMAP（Internet Mail Access Protocol，Internet邮件访问协议）`以前称作交互邮件访问协议（Interactive Mail Access Protocol）。IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。

IMAP和POP是最常见的读取邮件的Internet协议标准，目前在使用的绝大部分的邮件客户端和服务器都支持这两种协议。

**步骤6：E-Mail数据包的捕获**

我们这次的实验需要使用Foxmail客户端来收发邮件，并利用Wireshark将收发邮件过程中的数据包捕获下来进行分析。我在我的虚拟机中安装了Foxmail的7.2版本，然后将我的电子邮箱ioio_jy@sohu.com配置到Foxmail中，那么接下来就可以利用Foxmail客户端开始收发邮件的操作了。

这里可以首先打开Wireshark，在捕获选项中添加进tcp的筛选条件。然后在Foxmail中给我自己的邮箱发一封电子邮件，并附上我的一张照片作为附件（照片的具体内容，我这里先卖一个关子，下次课我会通过解密手段给大家看），如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/03.jpg)

在发送之前，先开启Wireshark进行监控，之后再回到Foxmail客户端进行发送，成功后就可以捕获到非常多的数据包了。由于是给我自己的邮箱发送邮件，所以我很快就能收到，那么我在收到并打开邮件后，Wireshark也会捕获到收取邮件的数据包，也就是我们这次的实验文件Lab20-1.pcapng。

**步骤7：发送邮件数据包分析**

打开实验文件以后，我们首先可以看到TCP的三次握手，毕竟SMTP是基于TCP协议的。下面我们把关注的重心放到SMTP的数据包上，使用筛选器只保留SMTP的数据包，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/04.jpg)

发送邮件的详细过程如下：

5：客户端向服务器发送的EHLO指令，用于向服务器表明自己的身份。从这个数据包的信息中，可以看到客户端的主机名称为jiang-1a3c6c581。

8：客户端发送的`AUTH LOGIN`指令，请求登录认证。

11：这里的User指令表示邮箱登录的用户名。可以看到这里是经过了加密的。SMTP不接收明文，必须要通过64位的编码后再发送。从后面的两个等于号基本可以确定，它采用的是Base64的加密形式，因为等于号在Base64中就是用于填充的。如果大家想要深入了解这方面的相关知识的实际应用，可以参考我所主讲的《恶意代码分析实战》课程的相关章节。

14：这里的Pass表示登录密码，同样采用了Base64进行加密。关于解密的方式，我会在下次课程中详细讲解。

16：这个数据包表示邮箱登陆成功：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/05.jpg)

17：发送邮件的账户，这里是ioio_jy@sohu.com。

20：接收邮件的账户，由于是给我自己写信，所以同样是ioio_jy@sohu.com。

23：DATA表示客户端发送的内容。

25：服务器端使用了``接收了文本的内容。因为SMTP属于请求/应答的模式，请求和应答都是基于ASCII文本，并以CR和LF（回车换行）为结束符。

26：所发送的数据，由于这个邮件包含的数据比较多，因此会分为多个数据包进行发送，也就是从26到140号数据包。

143：发送邮件的账户及主题等信息。

149：表示断开与邮件服务器的连接。

以上就是发送邮件的整个过程。如果想要查看发送邮件的详细信息，可以在任意一个数据包上单击鼠标右键，并选择`Follow TCP Stream`命令进行查看：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/06.jpg)

在这个对话框中就可以清晰的显示出邮件的信息，其中红色的部分是客户端发送的信息，蓝色部分是服务器响应的信息。并且还可以看到客户端的主机名、邮件账户、使用的邮件客户端、邮件内容类型和传输格式等。更重要的是，还可以看到邮件的内容以及附件的名称：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/07.jpg)

接下来的乱码是我们的附件经过加密后所得到的十六进制编码信息。这里同样是使用Base64进行加密的。关于这段代码的解密工作，我们在下次的课程中再进行论述。

**步骤8：接收邮件数据包分析**

为了能够方便地查看与接收邮件相关的数据包，这里我们需要使用筛选条件pop：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/08.jpg)

POP协议也是基于TCP协议的，所以在使用POP接收数据包之前同样会经过TCP的三次握手操作，只不过这里被过滤掉了。

159：这里的USER表示的是用户名，这里显示的是ioio_jy@sohu.com。

162：这里的PASS表示的是客户端输入的密码，这里的密码为jiangye。由于POP允许明文传输，所以这里输入的用户名和密码等信息都是以明文提供的。

164：说明用户名和密码验证成功。

165：是客户端向服务器发送的STAT命令，用于统计邮件信息。

168：发送了LIST命令，用于列出邮件的大小。

169：是对于上一个数据包的回应，回复了每个邮件的大小：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/09.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/09.jpg)

在Packet Details面板中，可以看到服务器响应客户端的邮件大小的情况。如`“1 77337\r\n”`，表示这是第一封邮件，大小为77337字节，`“\r\n”`是结束符。

174：客户端向服务器发送UIDL命令，请求邮件的唯一标识符。

176：服务器对于客户端的响应信息：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51487/10.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51487/10.jpg)

在上图中可以看到每封邮件的唯一标识符。

184：客户端向服务器发送的RETR命令，请求邮件的内容。

187：服务器响应客户端的请求，返回邮件的大小。一直到193号数据包都是邮件的大小。

194：显示了邮件的发送方是ioio_jy@sohu.com，主题为WiresharkTest，接下来的数据包就是邮件中的具体内容。

262：表示终止客户端与POP3服务器之间的连接。

经过上述分析，我们可以知道接收邮件的整个过程，接下来我们同样可以利用TCP Stream来查看邮件的信息。我们可以看到接收邮件的用户名、密码、邮件大小、邮件的唯一标识符及邮件的全部文本内容等信息。

#### 2.16 E-Mail数据包的解密

**实验环境**

- 操作机：`Windows XP`

**实验目的**

- 学习E-Mail数据包的解密

**实验工具**

- `wireshark`：Beyond Compare是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换，是目前全世界最广泛的网络封包分析软件
- `Beyond`：是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。

- `Base64`：是一款非常好用的Base64编-解码工具.转换很方便,支持中文,支持UTF-8，Unicode编码方式.

- `WinHex`：WinHex是一款非常不错的 16 进制编辑器。得到 ZDNetSoftwareLibrary 五星级最高评价，拥有强大的系统效用。

实验文件：

- `cipherfile.txt`
- `decodefile.py`
- `IMG_1014.JPG`
- `Lab21-1.pcapng`
- `plainfile.txt`
- `User&Pass.txt`

**实验内容**

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/11e1115b`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：用户名和密码的解密**

这里我们打开实验文件Lab21-1.pcapng，其实这次的文件和上次的是完全一样的。我们同样使用筛选器筛选出SMTP协议，找到加密的User以及Pass的部分：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/01.jpg)

我在上次的课程中说过，只要见到加密字符串的后面出现了等于号，那么就应当怀疑它使用的是Base64进行加密的。想要实现解密，最简单的方法可以使用现成的Base64解密软件，这里我是用的是Base64V1.6这款工具。User以及Pass的加密字符串已经放在了User&Pass.txt这个文件中，那么只要把想解密的内容拷贝到解密程序中即可：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/02.jpg)

可以看到，这里解密出的用户名是ioio_jy@sohu.com。同理可以知道，我的登录密码是jiangye。当然，我在结束本次课程的讲解后，密码就不是这个了。

除了使用现成的软件，我们也可以使用Python自带的解密函数库实现解密的操作。这里我所使用的Python版本为2.7，那么只要安装完毕，在开始菜单的Python 2.7目录中就可以找到IDLE，从而打开shell。接下来就可以通过Python代码进行解密了：

```
import base64
cipher = 'amlhbmd5ZQ=='
plaintext = base64.b64decode(cipher)
print plaintext
```

如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/03.jpg)

可以看到，使用这种方法同样可以实现解密的操作。

**步骤3：附件内容的解密**

这里我们可以通过TCP Stream再来查看一下附件的内容：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/04.jpg)

这里包含了附件的名称以及附件二进制数据加密后的内容。这里我们首先对其进行Base64的解密。我已经把加密的附件内容提取出来并保存在了cipherfile.txt文件中。那么接下来可以通过编写Python程序实现解密的操作：

```
# 导入解密函数库
import base64
# 打开并读取密码文件
cipher_file = open('cipherfile.txt')
cipher_text = cipher_file.read( )
# 利用导入库中的解密函数进行解密
plain_test = base64.b64decode(cipher_text)
cipher_file.close( )
# 创建解密文件
plain_file = open('plainfile.txt', 'w')
# 将解密内容写入文件
plain_file.write(plain_test)
plain_file.close( )
```

将这个解密程序（decodefile.py）以及密码文件（cipherfile.txt）放到C盘的根目录（主要是为了接下来的操作方便）。然后打开cmd，切换到C盘根目录，直接输入解密程序的文件名，然后可以看到在C盘根目录中就多出来一个名为plainfile.txt的解密文件了。

我们所得到的这个文件是一个二进制文件，直接利用记事本打开的话就是一堆乱码。因此下一步我们需要确定这个文件的类型。当然可能有朋友会说，我们不是已经在TCP Stream中看到了这个文件的名称是IMG_1014.JPG吗，那么为什么还要确定它的文件类型呢？确实，对于我们这次的实验而言，通过观察TCP Stream的内容就可以确定文件的类型。但是我们既然研究网络安全，就需要掌握文件类型分析的基本方法。因为我们在现实环境中所抓取的数据包中，发信人可能会为了起到保密的效果，而故意舍去文件的扩展名，或者干脆将原始文件的扩展名改成一个错误的扩展名。一旦遇到这种情况，就需要我们自己来确定这个文件的类型了，否则是打不开的。

这里我们使用文件格式识别工具（FFV.exe）来检测一下plainfile.txt这个文件：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/05.jpg)

可以看到，这款软件并没有受到目标文件扩展名的影响，准确地识别出了目标文件的类型，属于“JPEG联合图像专家组图形文件”。但是如果我们没有FFV.exe这款工具该怎么办呢？那么这就需要我们弄清楚每一种文件的格式信息。举个简单的例子，判断PE文件，最简单的办法是查看文件头部是否包含有MZ以及PE这几个字符，更进一步，如果想要分辨exe格式、sys格式以及dll格式的话，就需要对相关标志位进行解析了。其实这种思想对于判断其它文件类型也是适用的。不同的文件往往会在文件的头部加上自己文件的专属标志，图片文件也是如此，就比如说我们这次的这个JPG文件，它的开头的两个字节固定就是0xFFD8，那么由此就可以知道文件的格式了（有时也可以通过头部的JFIF标志辨别）。

下面我们就可以把plainfile.txt的扩展名修改为jpg了。那么现在不妨打开看看这个图片：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/06.jpg)

可以发现，图片虽然能够打开，但是图片的内容明显并不是我。看来我们还需要对其进行进一步的研究。

图像文件的基本属性，比如大小，颜色等信息是保存在二进制文件的头部的，通过查看这个文件的属性，可以看到重要的信息都在，说明文件的问题出在保存有图像具体信息的二进制代码中。初步考虑，可能是在网络传输的过程中，为了安全的考虑而做的第二次加密（当然是否真的是二次加密，需要经过分析才可以知道）。但是它究竟采用了怎样的加密方式，并不好判断。所以这里我决定将这个文件与原始的图片文件进行二进制层面的比较，以找到最终的原因。这里我使用Beyond Compare这款工具，将两个图片文件载入进行对比分析（Hex Compare）：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/07.jpg)

上图中，位于上面的是原始图片，下面的是我们刚刚解密出的图片。从两个文件的大小可以发现，解密后的文件比原始文件多了210个字节，那么弄清楚这210个字节的不同，也许就是解开谜题的关键。

Beyond Compare这款工具已经帮我们找到了二者的不同。仔细分析可以发现，相比而言，最大的不同在于我们解密出的文件多出来很多0x0D这个字节。这个字节的出现有什么规律呢？是不是每隔一定的字节数，就会重复出现呢？数一数似乎并不是这样。那就分析一下它周围的字节，可以发现所有0x0D的后面都紧跟着一个0x0A，而如果观察原始图片的二进制信息，可以发现0x0A前面并没有0x0D。

事实上，在ASCII码中0x0A表示的是换行键（LF），而0x0D表示的是回车键（CR）。我们上次课说过，服务器端使用了接收文本的内容。因为SMTP属于请求/应答的模式，请求和应答都是基于ASCII文本，并以CR和LF（回车换行）为结束符。这样我们就知道了，看来系统是在所有的换行键前面加上了一个回车键。

既然这样，我们就可以尝试一下，将我们解密得到的文件中所有的0x0D0A替换为0x0A。可以使用WinHex来完成这个操作。 首先使用WinHex打开plainfile.jpg，然后选择菜单栏中的“搜索”->“替换16进制值”，在弹出的对话框中分别填入0d0a以及0a，表示用后者替代前者，然后确定。此时WinHex会告诉我们已经替换了210处，实际上这也就说明文件缩小了210个字节，这与我们之前所发现的两个文件的大小差异是一致的。那么下面我们保存，然后再尝试打开这个文件：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51493/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51493/08.jpg)

可见，文件已经成功地打开了。我觉得这个图片和我真人相比较，还是非常的传神的。

#### 2.17 操作系统启动数据包解析

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/e9e20878`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：WinXP启动数据包的捕获**

为了能够捕获到其它操作系统的数据包，这里我需要使用VMWare这款虚拟机软件。我已经在这个虚拟机中安装了Windows XP SP3操作系统。那么我们就可以在Wireshark的捕获选项中的捕获对象中找到VMWare选项，我们勾选这个选项：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51495/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51495/01.jpg)

然后开始捕获并打开虚拟机，等系统彻底启动完毕之后，就可以抓取到非常多的数据包了（Lab22-1.pcapng）：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51495/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51495/02.jpg)

**步骤3：数据包的分析**

我们这次所捕获到的数据包非常大，其中可以发现非常多的TCP与DNS协议。这是因为我的这个虚拟系统中设置了开机启动项，也就是有些软件会在开机时自启动，并进行一些联网的操作。如果说不让这些软件启动，那么就不会出现这么多的TCP和DNS了。所以这里为了方便分析，我这里首先使用筛选器筛选掉TCP和DNS：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51495/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51495/03.jpg)

可以看到，在所捕获的数据包中有非常多的NBNS数据包。NBNS协议指的是网络基本输入/输出系统（NetBIOS）名称服务器。NBNS协议是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射的方法。

NetBIOS协议是由IBM公司开发，主要用于数十台计算机的小型局域网。该协议使得在局域网上的程序可以使用应用程序编程接口（API），为程序提供了请求低级服务的统一命令集，作用是为局域网提供网络以及其他特殊功能。系统可以利用WINS服务（Windows网络名称服务）、广播以及Lmhost（LAN Manager Hosts）文件等多种模式将NetBIOS名（指基于NetBIOS协议获得计算机名称）解析为相应的IP地址，以实现通信。所以，在局域网内部使用NetBIOS协议可以方便地实现消息通信及资源的共享。因为它占用系统资源少，传输效率高，所以几乎所有的局域网都是在NetBIOS协议的基础上工作的。

在Windows系统中，NetBIOS协议默认是开启的。所以将使用NBNS协议广播自己的主机名和工作组信息，以访问网络中的共享资源。从获取的数据包中可以看到，系统的主机名称是JIANG-1A3C6C581，所处的环境为工作组WORKGROUP。

第17和18号数据包使用了DHCP协议来获取IPv4的地址。2606和2625号数据包是请求加入组播组的数据包。因为加入了组播组之后可以识别并接收以该IP组播地址为目的地址的IP报文。通过组播传输数据，可以提高数据传输效率，并减少了网络出现拥塞的可能性。

接下来我们还可以看到ARP数据包。由于当前主机需要访问网络中的资源，所以必须通过路由器转发获取。由于系统刚刚启动，还没有记录任何主机的ARP条目，所以这里需要使用ARP协议请求获取到路由器（网关）的MAC地址，然后才可以连接到网络。如果包含有共享资源，那么还可以看到诸如SMB这样的协议。

下面我们取消筛选条件，来关注一下TCP以及DNS协议的情况。由于我的系统中安装了迅雷，并且设置了开机自启动，所以可以看到数据包中有关于迅雷的内容。比如56号数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51495/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51495/04.jpg)

在迅雷的数据包下面，还有kankan.com以及sandai.net，其实这都是迅雷的相关产品。并且通过抓包还可以清晰地看到，迅雷在开机启动时的网络特征，比如连接了哪些服务器，又启动了哪些我们平时注意不到的网络服务等。那么这里就不再赘述，大家有兴趣的话也可以查看一下有没有关于迅雷的其它数据包。

**步骤4：Kali Linux启动数据包分析**

我们在之前的课程中曾经对比分析过CIFS协议在WinXP以及Win7中的不同。其实通过这种对比分析的方式，更有助于我们理解协议的执行过程。特别是在运用了Wireshark这款工具的情况下，不同操作系统的特性也是一目了然。那么我们这次，也可以对比分析不同操作系统启动过程中的不同。那么这里对比的就是WinXP以及Kali Linux之间的不同。

数据包的捕获方式与WinXP是一致的，我的Kali Linux是1.0.7版本。所捕获到的数据包是Lab22-2.pcapng，下面可以利用Wireshark来简单分析一下：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51495/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51495/05.jpg)

由于并没有开机自启动程序，因此这个捕获文件明显没有刚才的那么大，也就少了非常多的TCP以及DNS数据包。可以看到，捕获文件的一开始出现了很多ICMPv6数据包，这是客户端请求获取IPv6地址的相关数据包。但是我们在分析刚才的捕获文件中，并没有看到这个数据包，这是因为WinXP默认是不支持IPv6的，而Kali Linux是支持的。想要在WinXP上使用IPv6很简单，可以打开cmd输入“ipv6 install”即可。

接下来还有ARP和DHCP数据包，这与WinXP的情况是一致的。另外，在刚才的捕获文件中发现了许多NBNS协议，因为Windows系统是默认开启了这个功能。但是在Kali Linux中我们并没有发现，可以认为这个协议并没有默认开启或者说它并不是Linux系统启动所必需的协议。

#### 2.18 一道有趣的网络工程师面试题

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/6d3aa528`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：问题概述与基本分析**

假设有A和B两台服务器，其中B的子网掩码本来应该是255.255.255.0，但是现在却被不小心配置成了255.255.255.224，那么A和B之间还可以正常通信吗？

既然这个问题主要与子网掩码有关，那么我们这里不妨先简单讲解一下IP地址与子网掩码的相关知识。 我们知道，IP地址是一个32位的地址，用来唯一标识连接到网络的设备。由于让人记住一串32位长的01字符确实比较困难，所以IP地址就采用了点分四组的表示方法。

在点分四组的表示方法中，以A.B.C.D的形式，构成IP地址的四组1和0分别转换为十进制的0到255之间的数。我们可以拿11000000 10101000 00000000 00000001这样的IP地址举例来说。这个值显然是不容易记住或者表示的。但是如果采用点分四组的表示方法，我们就可以将其表示为192.168.0.1。

IP地址之所以会被分成4个单独的部分，是因为每个IP地址都包含着两个部分：网络地址和主机地址。网络地址用来标识设备所连接到的网络，而主机地址则标识这个网络中的设备本身。用来决定究竟IP地址哪部分属于网络或者主机的划分通常并不唯一。这实际上是由另一组名为网络掩码（network mask）的地址信息所决定的，有时它也会被称为子网掩码（subnet mask）。 子网掩码用来标识IP地址中究竟哪一部分属于网络地址而哪一部分属于主机地址。子网掩码的长度也是32位，并且被设置为1的每一位都标识着IP地址的对应部分是属于网络地址的，而剩下设置为0的部分则标识为主机地址。

这里我们可以以IP地址为10.10.1.22为例，其二进制形式为00001010 00001010 00000001 00010110。为了能够区分出IP地址的每一部分，我们使用子网掩码。那么对于这个例子，我们假设其子网掩码为11111111 11111111 00000000 00000000。这就意味着IP地址的前一半（10.10或者00001010 00001010）是网络地址，而后一半（1.22或者00000001 00010110）标识着这个网络上的主机。

子网掩码也可以写成点分四组的形式。比如子网掩码11111111 11111111 00000000 00000000可以被写成255.255.0.0。 IP地址和子网掩码为了简便起见，通常会被写成无类型域间选路（Classless Inter-Domain Routing, CIDR）的形式。在这种形式下，一个完整的IP地址后面会有一个左斜杠（/），以及一个用来表示IP地址中网络部分位数的数字。举例来说，IP地址10.10.1.22和网络掩码255.255.0.0，在CIDR表示法下就会被写成10.10.1.22/16的形式。

好，那么基础知识就回顾到这里。但是即便我们再反复琢磨相关术语的定义，甚至看经典的教材进行研究，似乎也不知道这个面试问题的正确答案。因此，我们唯有通过Wireshark来进行抓包分析了。

**步骤3：数据包的捕获与分析**

依据题意，我们可以准备两台计算机A和B，将B的子网掩码设置为一个错误的值，然后在该计算机上开启嗅探，并且ping计算机A的IP地址。正常来说是可以ping通的，并且Wireshark也捕获到了相关的数据包，也就是实验文件Lab22-1.cap：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51497/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51497/01.jpg)

首先1号数据包是计算机B通过ARP广播查询默认网关192.168.26.2的MAC地址。那么为什么我们ping的是计算机A的IP，但是B却去查询默认网关的MAC地址呢？这是因为B根据自己的子网掩码，计算出A和自己属于不同的子网。而跨子网通信是需要默认网关来进行转发的。而如果想要和默认网关进行通信，就需要获取它的MAC地址。

接下来的2号数据包则是默认网关192.168.26.2向B回复了自己的MAC地址。

3号数据包就是由B发出的ping数据包，制定目的IP地址为A，也就是192.168.26.129。但是目标MAC地址却是默认网关的00:50:56:e7:2f:88。这就表明B希望默认网关把数据包转发给A。至于默认网关是否真的执行了转发的操作，我们这里无从得知，除非在该网关上也进行抓包分析。 4号数据包说明B收到了A发出的ARP广播，这个广播查询的是B的MAC地址。这是因为在A看来，B属于相同的子网，同一个子网进行通信并不需要默认网关的参与，只要通过ARP获取对方的MAC地址就可以了。这个数据包也表明默认网关成功地把B发出的ping请求转发给A了，否则A不会无缘无故地就尝试与B进行通信。

在5号数据包中，B回复了A的ARP请求，把自己的MAC地址告诉了A。这也就说明了，B在执行ARP回复的时候并不会考虑子网的问题。虽然ARP请求来自于其它子网的IP，但是也会照样回复。

6号数据包是B收到了A的ping回复。从MAC地址00:0c:29:0c:22:10可以看出，这个数据包是直接由A发送来的，而不是通过默认网关转发的。

后面的7到10号数据包都是重复的ping请求和ping回复。因为A和B都已经知道了对方的联系方式，因此就没有必要再发ARP了。

分析至此可以知道，整个通信过程，首先B会把ping请求交给默认网关，然后默认网关再转发给A。而A收到请求之后，就直接把ping回复给B。那么这也就说明，在题目的要求配置下，A和B之间还是可以正常通信的。

#### 2.19 无线网络数据包初探

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/485b1a2f`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：了解802.11数据包的结构**

这里我们结合实验文件Lab24-1.pcap进行讲解：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/01.jpg)

无线网络数据包与有线网络数据包最大的不同在于额外的802.11头部。这是一个位于第二层的头部，包含与数据包和传输介质有关的额外信息。802.11数据包一共有三种类型：

管理：这类数据包用于在主机之间建立第二层的连接。管理数据包还有一些重要的子类型，包括认证（authentication）、关联（association）和信号（beacon）数据包。而我们现在所研究的就是信号数据包。

数据：这类数据包包含有真正的数据，也是唯一可以从无线网络转发到有线网络的数据包。

控制：控制数据包允许管理数据包和数据数据包的发送，并与拥塞管理有关。常见的子类型包括请求发送（request-to-send）和准予发送（clear-to-send）数据包。

一个无线数据包的类型和子类型决定了它的结构，因此各种可能的数据包结构不计其数。我们现在研究的beacon管理数据包是最有信息量的无线数据包之一。它作为一个广播数据包由WAP（Wireless Access Point，无线接入点）发送，穿过无线信道通知所有无线客户端存在这个可用的WAP，并定义了连接它必须设置的一些参数。比如上图中可以看到，这个数据包在802.11头部的Type/Subtype域被定义为beacon。

在802.11管理帧的头部也包含有其它的一些信息，主要有： Timestamp：发送数据包的时间戳。 Beacon Interval：Beacon数据包的重传间隔。 Capabilities Information：WAP的硬件容量信息。 SSID Parameter Set：WAP广播的SSID（网络名称）。 Supported Rates：WAP支持的数据传输率。 DS Parameter：WAP广播使用的信道。 这个头部也包含了来源和目的地址以及厂商信息。

这样我们就可以知道，在这个捕获文件中，显然是一台D-Link设备，使用802.11b标准，在信道11上工作。

虽然802.11管理数据包的具体内容和用途不太一样，但是总体结构和这个例子差别不大。

**步骤3：在Packet List面板增加无线专用列**

Wireshark通常在Packet List面板中会显示7个不同的列。但是鉴于无线数据报的特殊性，我们需要在Packet List面板增加三个新的列。选择菜单栏的“Edit”->“Preferences”，选择左边的Columns，并点击Add。在Title域输入RSSI，并在域类型下拉列表中选择IEEE 802.11 RSSI。同理，再添加一个名为TX Rate，类型为IEEE 802.11 TX rate以及名为Channel/Frequency，类型为Channel/Frequency的列：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/02.jpg)

新添加的每个列说明如下： RSSI（for Received Singnal Strength Indication）列，显示捕获数据包的射频信号强度。 TX Rate（for Transmission Rate）列，显示捕获数据包的数据率。 Channel/Frequency列，显示捕获数据包的频率和信道。

当处理无线连接时，这些提示信息将会非常有用。例如，即使你的无线客户端软件告诉你信号强度很棒，我们亲自捕获数据包并检查这些列，也许会得到与客户端软件告诉我们的结果不一样的数字。

接下来单击Apply和OK使设置生效即可。

**步骤4：WEP认证分析**

部署和管理无线网络时最大的担忧就是数据传输的安全性。因为数据在空气中传播，任何人都可以得到它，因此数据的加密是至关重要的。最初推荐用在无线网络中加密传输数据的技术依据的是“有线等效加密”（Wired Equivalent Privacy，WEP）标准。WEP在最开始的时候很成功，直到后来被发现它在密钥管理方面存在几个漏洞。为了加强安全，几个新的标准又被设计出来。这就包括了无线上网保护接入（Wi-Fi Protected Access，WPA）和WPA2标准。尽管WPA和比它更安全的WPA2依旧不是十全十美，但是也比WEP强多了。那么下面我们就来分析一下WEP以及WPA的认证数据包。

我们先打开实验文件Lab24-2.pcap，这个捕获文件里面包含了成功连接WEP无线网络的例子。这个网络使用WEP安全机制。用户必须向无线网络接入点（WAP）提供一个密码，以通过认证并解密它发来的数据。这个WEP的密码可以当作无线网络的密码：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/03.jpg)

在第4个数据包中，它是从无线网络接入点（00：11：88：6b：68：30）发送到无线客户端（00：14：a5：30：b0：af）的质询开始。这个质询的目的是确认无线客户端是否有正确的WEP密码。展开数据包头部中的Tagged parameters，就可以看到这个质询。

在第6个数据包中，这个数据包被确认。然后无线客户端将用WEP密码解密的质询文本返回给WAP：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/04.jpg)

8号数据包是WAP对于无线客户端的响应，响应里面包含了一个说明认证成功的通知：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/05.jpg)

认证成功之后，客户端可以发送关联（association）请求、接收请求、完成连接过程：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/06.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/06.jpg)

接下来我们分析一下实验文件Lab24-3.pcap。这个文件是一位用户输入他的WEP密码连接到WAP，几秒后，无线客户端程序报告无法连接到无线网络，但是并没有给出原因。可以看到，与连接成功的时候一样，通信从3号数据包开始，这个数据包是WAP发送给无线客户端的质询文本。这个消息被成功确认了。接着，在5号数据包中，无线客户端使用用户提供的WEP密码发送了响应。

按道理，如果一切正常，应该会收到一个通知告诉我们认证成功了。但是如果我们查看7号数据包，却看到了不一样的情况：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/07.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/07.jpg)

这个消息告诉我们无线客户端对质询文本的响应不正确。表明客户端用以解密质询文本的WEP密码肯定是输入错误，从而导致了连接失败。必须要使用正确的密码重试才可以。

**步骤5：WPA认证分析**

WPA使用了与WEP完全不同的认证方式，但是它仍然依赖于用户在无线客户端输入密码来连接到网络。实验文件Lab24-4.pcap是一个成功认证的例子：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/08.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/08.jpg)

这个捕获文件的第一个数据包是WAP发送的beacon广播。展开这个数据包的802.11头部，沿着tagged parameters往下看，展开Vendor Specific标题，就可以看到无线接入点的WPA属性部分。可以看到，无线接入点支持WPA，以及版本与实现厂商。 无线客户端在接收到这个beacon广播之后，就向无线接入点发送一个探测请求，并得到了响应。无线客户端和无线接入点在4~7号数据包之间生成认证与关联的请求以及响应。 接下来看一下8号数据包。这是WPA开始握手的地方一直持续到11号数据包。这个握手的过程就是WPA质询响应的过程：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/09.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/09.jpg)

这里有两个质询与响应。每个数据包都可在基于802.1x Authentication头部下的Replay Counter域找到匹配对象。注意到前两个握手数据包的Replay Counter的值是1，而后两个握手数据包的值是2，相同的值表示为互相配对。 当WPA握手完成、认证成功之后，数据就开始在无线客户端和WAP之间传输了。 最后我们再来研究一下实验文件Lab24-5.pcap。这是一个失败的认证过程。与WEP一样，当用户输入WPA的密码之后，无线客户端程序报告无法连接到无线网络，但是并没有指出问题在哪里，所以现在就有必要来看看发生了什么。 如同刚才成功的WAP认证一样，捕获文件以同样的方式开始。包括探测、认证和关联请求。WPA握手的过程是从8号数据包开始的。但是在这个捕获文件中，我们看到了8个握手数据包，而不是之前的4个：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51499/10.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51499/10.jpg)

8号和9号数据包是表示WPA握手的前两个数据包。但是在这个例子中，客户端发送回WAP的质询文本有错误。结果这个序列在数据包10和11、12和13、14和15中多次重复。使用Replay Counter值可以配对每个请求和响应。

在握手过程重复4次之后，通信就能终止了，16号数据包表示客户端没有通过认证。

## 三、排错篇

#### 3.1 因配置错误而导致的网络故障

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/a9525b1c`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：Wireshark部署概述**

我们之前的研究，都是在本机上利用Wireshark进行抓包分析的。但是在现实的网络环境中，由于计算机众多，那么在故障定位时究竟应当采用哪种手段如何部署Wireshark进行抓包分析，往往是能否顺利解决问题的关键。作为网络数据包分析师，我们需要让自己的捕获尽量隐秘，以最大限度地捕获到最为原始的数据包。仅仅采集我们所需要的数据，而不留下任何的痕迹。下图展示了数据包捕获的常用方法，大家在实际的分析过程中可以拿来参考：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51503/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51503/01.jpg)

上图只是一个简单的通用参考，并不涵盖所有用来监听网络线路的可能方法。对于每种方法的概述如下：

1、端口镜像：通常是首选的方法，因为它不会留下网络痕迹，也不会因此而产生额外的数据包。可以在不让客户端脱机下线的情况下进行配置，非常便于镜像路由器或者服务器端口。

2、ARP欺骗：也称为ARP缓存中毒。这种方式会被认为比较草率，因为这种方法涉及在网络上注入数据包，这就会加重路由流经嗅探器的网络流量，但是这会有助于我们的分析。如果需要一个暂时性快速实施的方法，能够将一个设备的网络流量进行捕获，而又不用将其下线，同时端口镜像又不被支持的时候，这种方法就是一个高效的选择。

3、集线器输出：如果不需要考虑主机暂时下线带来的后果，那么可以采用这种方法。但是如果需要捕获多台主机的流量时，效率会很低，因为碰撞和丢包会导致性能低下。

4、使用网络分流器：这种方式在不需要考虑主机暂时下线带来的后果时适用。或者在需要嗅探光纤通信时，这是唯一的选择。由于网络分流器就是为了网络监听嗅探而设计的，而且能够跟上现代网络速度，因此这种方法比起集线器输出要更加高效。但是如果预算紧张，那么这种方式的成本会比较高昂。

5、直接安装：这种方式并没有在上图中表现出来。它是指仅仅在单个系统上安装嗅探器软件并监听这台系统的进出流量。这种方式一般是不建议采用的，因为如果一台主机存在故障和问题，这个问题就可能会导致数重要据包被丢弃，于是就无法表现出网络的原始面貌了。但是在进行环境测试、评估和性能审查，或者是检查在其他地方捕获的数据包文件时，这就是最佳方案。

**步骤3：了解网络情景与监听方式**

在我们这次的场景中，出现的问题是用户不能访问Internet。现在可以确定的是，该用户可以访问所有的内网资源，包括其他工作站的共享内容，以及运行在本地服务器上的应用程序。

这个网络的构架也非常简单，所有客户机和服务器都连接到一系列的简单交换机上。Internet连接由一个路由器处理，作为默认网关。IP地址信息由DHCP提供。其实这是小型办公室的常见配置。

那么为了找出问题的原因，我们可以一边用嗅探器监听线路，一边让用户尝试浏览Internet。并且根据上图来决定放置嗅探器的最佳方法。在这里，网络上的交换机不支持端口镜像，假设客户可以暂时下线，那么使用网络分流器就是最佳的选择了。从而得到捕获文件Lab25-1.pcap。

这里给大家稍微介绍一下网络分流器。网络分流器（Network probe）是一个独立的专门用于网络分析的硬件设备，它不会对已有网络设备的负载带来任何影响，这与端口镜像等方式相比具有极大的优势。可以将它放置在网络布线系统的两个端点之间，来捕获这两个端点之间的数据包。网络分流器一般有两种：聚合的和非聚合的网络分流器。两种分流器的配置如下：

**1、聚合的网络分流器**

聚合的网络分流器的使用方法是最简单的，它只有一个物理的流量监听口，来对双向通信进行嗅探。为了使用聚合的网络分流器来截获一台接入交换机的电脑的网络流量，需要如下进行配置：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51503/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51503/02.jpg)

（1）从交换机上拔下目标计算机的网线。 （2）将连接目标计算机网线的另一端插入网络分流器的in端口中。 （3）将另一根网线的一段插入到网络分流器的out端口，并将另一端插入到网络交换机。 （4）将最后一根网线的一端插入网络分流器的monitor端口，并将另一端插入到作为嗅探器所使用的电脑上。 一旦连接好以后，嗅探器就可以捕获到接入网络分流器的所有网络流量了。

**2、非聚合的网络分流器**

非聚合的网络分流器比聚合的稍微复杂一些，它在进行流量的捕获时也有着更好的灵活性。与聚合网络分流器只有一个监听端口来嗅探双向通信流量所不同的是，非聚合的网络分流器有两个监听端口。一个监听端口是用来嗅探流出方向的网络流量（从电脑到分流器的端口方向），另一个监听端口是用来嗅探流入方向的网络流量（从分流器端口到电脑的方向）。 为了捕获一台连接交换机的电脑的所有流入流出的网络流量，需要进行如下配置：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51503/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51503/03.jpg)

（1）从交换机上拔下电脑连接网线。 （2）将电脑连接网线的另一端插入到网络分流器的in端口上。 （3）将另一根网线的一端插入到网络分流器的out端口，然后将另一端插入到网络交换机上。 （4）将第三根网线插入到网络分流器的Monitor A端口，并将另一端插入到作为嗅探器使用的电脑的一块网卡接口上。 （5）将最后一根网线插入到网络分流器的Monitor B端口，并将另一端插入到作为嗅探器使用的电脑的第二块网卡接口上。

**步骤4：数据包分析**

这里我们分析一下所捕获的数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51503/04.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51503/04.jpg)

可以看到，捕获文件从ARP的请求与响应作为开始。用户计算机的MAC地址是00:25:b3:bf:91:ee，IP地址是172.16.0.8。在1号数据包中，用户计算机发送了一个ARP广播数据包给网络上的所有计算机。想要获取默认网关172.16.0.10的MAC地址。

根据2号数据包中收到的响应，用户计算机知道了172.16.0.10的MAC地址是00:24:81:a1:f6:79。收到这个响应之后，计算机就有了到达网关的路由，而网关应该可以引导它接入Internet。

在ARP响应之后，计算机会在3号数据包中请求将网站的域名解析为IP地址：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51503/05.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51503/05.jpg)

如上图所示，计算机发送一个DNS查询数据包到它的首选DNS服务器4.2.2.2。正常情况下，DNS服务器会很快响应DNS查询，但是在这个例子中并非如此。我们并没有看到任何的响应，却发现了同样的DNS查询再次发送到不同的目的地址。比如4号数据包发送到了4.2.2.1，这是预先配置好的备用DNS服务器。

由于计算机仍然没有从DNS服务器收到响应，于是1秒之后，计算机又利用5号数据包再次发出DNS查询到4.2.2.2。接下来由于依旧没有得到响应，于是这个过程不断重复，交替向配置好的首选DNS服务器和备用DNS服务器发送请求。整个过程大概持续了8秒，其实这正是用户的Internet浏览器报告该页无法访问之前所花费的时间。

基于这些所捕获到的数据包，我们就可以开始查明问题的根源了。首先，我们看到一个ARP请求成功地抵达网络上我们认为的默认网关，所以我们知道网关设备在线并且可以连接。我们也知道用户的计算机确实可以在网络上传输数据包，所以我们可以假设本机的协议栈没有问题。那么显然问题就出在与DNS请求相关的设备上。

就这个网络来说，DNS请求是由Internet上的外部服务器（4.2.2.2或4.2.2.1）解析的。这就说明了，想要顺利解析的话，负责将数据包路由到Internet的路由器必须成功将DNS查询转发到服务器，而且服务器必须响应。否则，就无法使用HTTP请求Web页面。

我们知道其他用户上网都没有问题，这就告诉我们网络路由器和远程DNS服务器也许不是问题的原因所在。剩下的唯一可能就是用户自己的计算机出现了问题。

那么在进一步检查这台故障的计算机后，我们发现它不接受DHCP分配的地址，而是手动配置了地址信息，并且默认网关地址设置错了。被设置为默认网关的地址并不是一台路由器，所以它并不能够将DNS查询数据包转发到网络之外。

#### 3.2 让WireShark帮我们揪出意外的重定向

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/510b4911`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：网络情景概述**

这次我们所要研究的网络情景，也是一位不能够在工作站上网的用户。然而，与上一位用户所不同的是，这个用户可以访问Internet，但是却不能够访问Google的主页`http://www.google.com/`。这个用户每次想访问Google的时候，都会被重定向到一个浏览器页面“无法显示此网页”，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51509/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51509/01.jpg)

并且这个问题只影响该用户一个人，也就是只有他自己的计算机有这种问题。与之前的网络环境一样，这是一个只有一些简单交换机和一个简单路由器网关的小型网络环境。那么我们依旧可以利用网络分流器，一边监听流量，一边让用户尝试浏览`http://www.google.com/`，从而捕获到了实验文件Lab26-1.pcap。

**步骤3：数据包分析**

可以看到，实验文件是以ARP的请求和响应开始的：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51509/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51509/02.jpg)

在1号数据包里面，用户计算机的MAC地址是`00:25:b3:bf:91:ee`，IP地址是`172.16.0.8`，它向网段上的所有计算机发送一个ARP广播数据包，试图获取主机172.16.0.102的MAC地址，这是我们目前还不知道的一个地址。

在数据包2中，用户的计算机了解到IP地址`172.16.0.102`的MAC地址是`00:21:70:c0:56:f0`。根据上一次的课程，我们也许会猜测这是网关路由器的地址。通过这个地址，数据包就可以被再次转发到外部DNS服务器。但是下一个数据包并不是DNS请求，而是从172.16.0.8到172.16.0.102的TCP数据包。并且它还设置了`SYN标志`，表示这是两台主机之间建立TCP三次握手时的第一个数据包。

显然，试图连接到172.16.0.102的80端口的TCP连接通常与HTTP的流量相关。如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51509/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51509/03.jpg)

当主机172.16.0.102发回带有RST和ACK标志的TCP数据包之后，连接就中断了。我们在TCP的课程中讲过，带有RST标志的数据包是用来结束TCP连接的。在这个实验场景中，主机172.16.0.8尝试与主机172.16.0.102的80端口建立`TCP连接`。但是目标主机并没有配置好在80端口监听请求的服务，于是只能够发送TCP的RST数据包来结束连接。可以看到接下来这个过程又重复了两次。最后，用户就在网页浏览器上看到了“无法显示此网页”的提示。

在查看了其它工作正常的网络设备的配置信息后，1号和2号数据包中的ARP请求和响应引起了我们的注意。因为ARP请求并不是指向网关路由器的真实MAC地址，而是其它未知设备。在ARP请求和响应之后，我们期望看到发送给DNS服务器的请求，以得到www.google.com的IP地址，但事实上我们并没有看到。阻止DNS查询常见有两个条件：

1、发起连接的设备在DNS缓存中已经有域名到IP地址的映射。 2、发起连接的设备在hosts文件中已经有域名到IP地址的映射。

那么依据上述两点，进一步检查这个计算机之后，我们发现它的hosts文件中有一个`www.google.com`表项，对应一个内网IP地址172.16.0.102。而这个错误的表项就是用户问题的根源。

这里我们可以举一个例子，在Windows系统中，我们打开C:\Windows\System32\drivers\ect，其中有一个hosts文件。我们可以在其中加入一个新的条目：

127.0.0.1 www.ichunqiu.com 那么此时我们尝试用浏览器访问“i春秋”的网站，就会发现已经打不开了。其实这个原理与该用户的情况是一样的。计算机通常都把hosts文件当作域名-IP地址配对的可信来源，并且会在查询外部来源之前检索它。在这个场景中，用户计算机检查它的hosts文件，发现有一个www.google.com的表项，就认为www.google.com在本地的网段中。接着，它向这个主机发送ARP请求，并得到了响应，然后尝试向172.16.0.102的80端口发起TCP连接。然而，由于该系统并没有配置为Web服务器，所以它不可能接受这个连接请求。那么只要将`hosts文件`中的表项移除，就可以正常访问www.google.com了。

事实上，这个场景非常普遍。恶意程序在多年前就使用这种方法，将用户重定向到存放恶意程序的网站。试想，如果黑客修改了你的`hosts文件`，那么你每次在登录网上银行的时候，实际上访问的却是一个伪造的网站，专门窃取用户的金钱，其后果是非常严重的。虽说这种技术早就存在，但是恶意程序发展至今，黑客往往也会采用新的方式来利用hosts文件达到自己的目的，往往会使人防不胜防。有兴趣研究这方面安全技术的朋友，可以参考我所主讲的《恶意代码分析实战》的相关章节内容，或者《病毒木马查杀实战》的“txt病毒分析”的课程。

#### 3.3 问题有时出现在对方身上

**实验步骤**

**步骤1：下载实验文件**

请访问`http://file.ichunqiu.com/39fe541e`下载**实验文件**。

> **小i提示**：
>
> - 在本次实验中,请注意实验工具、实验文件存放路径,不同的文件路径可能会出现不一样的实验结果。
> - 在实验环境中无法连接互联网，请使用您本地的网络环境。

**步骤2：网络情景概述**

我们这次的网络情景与前两个情景基本是一样的。这次，有一位用户抱怨他的工作站不能够上网，后来发现，其实只是不能够访问**[http://www.google.com/]**这个网站。进一步的研究分析之后，发现这个问题在该机构中每个人身上都存在，也就是所有的计算机都不能访问Google了。这个环境的网络配置和前两个场景是一样的，仍然是使用一些简单的交换机和一个路由器将网络连接到Internet。

那么为了解决这个问题，我们需要访问**[[http://www.google.com](http://www.google.com/)]**这个网站来生成必要的数据包。由于所有人都访问不了Google，说明这是一个全网的问题，影响着每一个人的计算机，而且很可能是感染了恶意程序导致的。正因为如此，就不应该直接在该网络环境中的设备上进行嗅探。当我们在现实中遇到类似这样的问题时，使用网络分流器是最好的解决方案，因为它允许我们在短暂中断服务后完全被动地获取流量。通过网络分流器获得的捕获文件就是Lab27-1.pcap。

**步骤3：数据包分析**

这个数据包一开始所捕获到的是DNS数据包，而不是我们之前看到的ARP数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51511/01.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51511/01.jpg)

因为这里所捕获到的第一个数据包发往一个外部地址，并且2号数据包包含了来自那个地址的响应，于是我们就可以假设ARP的过程已经是完成了，并且网关路由器的MAC-IP地址映射已经存在于主机的ARP缓存中。

如上图所示，捕获文件中的第一个数据包是从主机172.16.0.8发往地址4.2.2.1，并且它是一个DNS数据包。通过查看数据包的内容，可以知道这是一个查询www.google.com的A记录的请求。接下来我们看一下2号数据包：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51511/02.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51511/02.jpg)

第2个数据包是来自4.2.2.1的响应。查看Packet Details面板，我们发现响应这个请求的名称服务器提供了多个应答，此时看起来并没有什么问题。

现在用户计算机已经得到了Web服务器的IP地址，它可以尝试与服务器进行通信了。通信的过程是3号数据包开始的，如下图所示：

[![Alt text](https://static2.ichunqiu.com/icq/resources/fileupload/51511/03.jpg)](https://static2.ichunqiu.com/icq/resources/fileupload/51511/03.jpg)

这个数据包是一个从172.16.0.8发往74.125.95.105的TCP数据包。这个目标地址来源于数据包2里面DNS查询响应提供的第1个A记录。TCP数据包设置了SYN标志，并尝试连接远程服务器的80端口。

因为这是一个TCP握手的过程，我们知道应当在响应中看到TCP SYN/ACK数据包，但是相反，主机过了一会又发了另一个SYN数据包到对方主机。并且在过了大约1秒后，主机又发送了一个SYN的数据包。之后通信就停止了，于是网页浏览器就报告找不到网站。

此时，我们想到由于能够成功向外部DNS服务器提交查询请求，所以网络内的工作站可以连接到外网。DNS服务器响应了一些看起来有效的IP地址，然后我们的主机就尝试向其中的一个地址建立连接。而且我们尝试连接的本地工作站看起来功能也很正常。

现在的问题是，远程服务器并没有响应我们的连接请求，连TCP RST这样的数据包都没有发过来。这种情况的原因有以下几种： 1、Web服务器配置错误 2、Web服务器的协议栈崩溃 3、远程网络部署了诸如防火墙这样的数据包过滤设备

假设本地网络没有数据包过滤设备，那所有的可能解决方法都在远程的网络上，这就超出了我们的控制范围。在这个案例中，Web服务器工作不正常，导致我们所有的尝试都失败了。那么一旦对方网站修复了故障，通信就可以继续了。





https://whatiwhere.gitee.io/blog/tags/Tools/page/3/